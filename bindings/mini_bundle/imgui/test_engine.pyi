import sys
from typing import List, Any, Optional, Tuple, Callable, overload
import numpy as np
import enum
from mini_bundle.imgui import  internal as internal
from mini_bundle import imgui as imgui
from mini_bundle.imgui import (
    WindowFlags, TableFlags, PopupFlags, ImVec2, ImVec4, KeyChord, Viewport, ImU64, ImWchar,
    TableSortSpecs, MouseButton, Key, Dir, SortDirection, Dir_
)
from mini_bundle.imgui.internal import (
    ItemStatusFlags, DockNode, Axis, Window, ImRect, Context, ItemFlags, LastItemData, TextBuffer,
    TabBar, InputSource,
)

ID = int
Str = str
Key_None = Key.none
TestInputType_None = TestInputType.none
TestRunFlags = int
TestCheckFlags = int
TestFlags = int
TestOpFlags = int
TestLogFlags = int

TestVerboseLevel_Warning = TestVerboseLevel.warning
TestVerboseLevel_Info = TestVerboseLevel.info
TestOpFlags_None = TestOpFlags_.none
TestRunFlags_None = TestRunFlags_.none
TestRunSpeed_Fast = TestRunSpeed.fast
TestFlags_None = TestFlags_.none
Dir_None = Dir_.none
TestActiveFunc_None = TestActiveFunc.none
TestGroup_Unknown = TestGroup.unknown
TestStatus_Unknown = TestStatus.unknown
InputSource_Mouse = InputSource.mouse

Function_TestRunner = Callable[[TestContext], None]
Function_TestGui = Callable[[imgui.test_engine.TestContext], None]

# fmt: off

##################################################
#    AUTO GENERATED CODE BELOW
##################################################
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:imgui_te_engine.h>    ####################
# dear imgui test engine
# (core)
# This is the interface that your initial setup (app init, main loop) will mostly be using.
# Actual tests will mostly use the interface of imgui_te_context.h

# -------------------------------------------------------------------------
# Forward Declarations
# -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# Types
# -------------------------------------------------------------------------

class TestActiveFunc(enum.Enum):
    """Stored in ImGuiTestContext: where we are currently running GuiFunc or TestFunc"""

    # ImGuiTestActiveFunc_None,    /* original C++ signature */
    none = enum.auto()  # (= 0)
    # ImGuiTestActiveFunc_GuiFunc,    /* original C++ signature */
    gui_func = enum.auto()  # (= 1)
    # ImGuiTestActiveFunc_TestFunc    /* original C++ signature */
    # }
    test_func = enum.auto()  # (= 2)

class TestRunSpeed(enum.Enum):
    # ImGuiTestRunSpeed_Fast          = 0,        /* original C++ signature */
    fast = (
        enum.auto()
    )  # (= 0)  # Run tests as fast as possible (teleport mouse, skip delays, etc.)
    # ImGuiTestRunSpeed_Normal        = 1,        /* original C++ signature */
    normal = enum.auto()  # (= 1)  # Run tests at human watchable speed (for debugging)
    # ImGuiTestRunSpeed_Cinematic     = 2,        /* original C++ signature */
    cinematic = (
        enum.auto()
    )  # (= 2)  # Run tests with pauses between actions (for e.g. tutorials)
    # ImGuiTestRunSpeed_COUNT    /* original C++ signature */
    # }
    count = enum.auto()  # (= 3)

class TestVerboseLevel(enum.Enum):
    # ImGuiTestVerboseLevel_Silent    = 0,        /* original C++ signature */
    silent = enum.auto()  # (= 0)  # -v0
    # ImGuiTestVerboseLevel_Error     = 1,        /* original C++ signature */
    error = enum.auto()  # (= 1)  # -v1
    # ImGuiTestVerboseLevel_Warning   = 2,        /* original C++ signature */
    warning = enum.auto()  # (= 2)  # -v2
    # ImGuiTestVerboseLevel_Info      = 3,        /* original C++ signature */
    info = enum.auto()  # (= 3)  # -v3
    # ImGuiTestVerboseLevel_Debug     = 4,        /* original C++ signature */
    debug = enum.auto()  # (= 4)  # -v4
    # ImGuiTestVerboseLevel_Trace     = 5,    /* original C++ signature */
    trace = enum.auto()  # (= 5)
    # ImGuiTestVerboseLevel_COUNT     = 6    /* original C++ signature */
    # }
    count = enum.auto()  # (= 6)

class TestStatus(enum.Enum):
    """Test status (stored in ImGuiTest)"""

    # ImGuiTestStatus_Unknown     = -1,    /* original C++ signature */
    unknown = enum.auto()  # (= -1)
    # ImGuiTestStatus_Success     = 0,    /* original C++ signature */
    success = enum.auto()  # (= 0)
    # ImGuiTestStatus_Queued      = 1,    /* original C++ signature */
    queued = enum.auto()  # (= 1)
    # ImGuiTestStatus_Running     = 2,    /* original C++ signature */
    running = enum.auto()  # (= 2)
    # ImGuiTestStatus_Error       = 3,    /* original C++ signature */
    error = enum.auto()  # (= 3)
    # ImGuiTestStatus_Suspended   = 4,    /* original C++ signature */
    # }
    suspended = enum.auto()  # (= 4)

class TestGroup(enum.Enum):
    """Test group: this is mostly used to categorize tests in our testing UI. (Stored in ImGuiTest)"""

    # ImGuiTestGroup_Unknown      = -1,    /* original C++ signature */
    unknown = enum.auto()  # (= -1)
    # ImGuiTestGroup_Tests        = 0,    /* original C++ signature */
    tests = enum.auto()  # (= 0)
    # ImGuiTestGroup_Perfs        = 1,    /* original C++ signature */
    perfs = enum.auto()  # (= 1)
    # ImGuiTestGroup_COUNT    /* original C++ signature */
    # }
    count = enum.auto()  # (= 2)

class TestFlags_(enum.Enum):
    """Flags (stored in ImGuiTest)"""

    # ImGuiTestFlags_None                 = 0,    /* original C++ signature */
    none = enum.auto()  # (= 0)
    # ImGuiTestFlags_NoGuiWarmUp          = 1 << 0,       /* original C++ signature */
    no_gui_warm_up = (
        enum.auto()
    )  # (= 1 << 0)  # Disable running the GUI func for 2 frames before starting test code. For tests which absolutely need to start before GuiFunc.
    # ImGuiTestFlags_NoAutoFinish         = 1 << 1,       /* original C++ signature */
    no_auto_finish = (
        enum.auto()
    )  # (= 1 << 1)  # By default, tests with no TestFunc (only a GuiFunc) will end after warmup. Setting this require test to call ctx->Finish().
    # ImGuiTestFlags_NoRecoveryWarnings   = 1 << 2        /* original C++ signature */
    no_recovery_warnings = (
        enum.auto()
    )  # (= 1 << 2)  # Disable state recovery warnings (missing End/Pop calls etc.) for tests which may rely on those.
    # ImGuiTestFlags_RequireViewports   = 1 << 10

class TestCheckFlags_(enum.Enum):
    """Flags for IM_CHECK* macros."""

    # ImGuiTestCheckFlags_None            = 0,    /* original C++ signature */
    none = enum.auto()  # (= 0)
    # ImGuiTestCheckFlags_SilentSuccess   = 1 << 0    /* original C++ signature */
    # }
    silent_success = enum.auto()  # (= 1 << 0)

class TestLogFlags_(enum.Enum):
    """Flags for ImGuiTestContext::Log* functions."""

    # ImGuiTestLogFlags_None              = 0,    /* original C++ signature */
    none = enum.auto()  # (= 0)
    # ImGuiTestLogFlags_NoHeader          = 1 << 0        /* original C++ signature */
    no_header = (
        enum.auto()
    )  # (= 1 << 0)  # Do not display frame count and depth padding

class TestRunFlags_(enum.Enum):
    # ImGuiTestRunFlags_None              = 0,    /* original C++ signature */
    none = enum.auto()  # (= 0)
    # ImGuiTestRunFlags_GuiFuncDisable    = 1 << 0,       /* original C++ signature */
    gui_func_disable = (
        enum.auto()
    )  # (= 1 << 0)  # Used internally to temporarily disable the GUI func (at the end of a test, etc)
    # ImGuiTestRunFlags_GuiFuncOnly       = 1 << 1,       /* original C++ signature */
    gui_func_only = enum.auto()  # (= 1 << 1)  # Set when user selects "Run GUI func"
    # ImGuiTestRunFlags_NoSuccessMsg      = 1 << 2,    /* original C++ signature */
    no_success_msg = enum.auto()  # (= 1 << 2)
    # ImGuiTestRunFlags_NoStopOnError     = 1 << 3,    /* original C++ signature */
    no_stop_on_error = enum.auto()  # (= 1 << 3)
    # ImGuiTestRunFlags_NoBreakOnError    = 1 << 4,    /* original C++ signature */
    no_break_on_error = enum.auto()  # (= 1 << 4)
    # ImGuiTestRunFlags_EnableRawInputs   = 1 << 5,       /* original C++ signature */
    enable_raw_inputs = (
        enum.auto()
    )  # (= 1 << 5)  # Disable input submission to let test submission raw input event (in order to test e.g. IO queue)
    # ImGuiTestRunFlags_ManualRun         = 1 << 6,    /* original C++ signature */
    manual_run = enum.auto()  # (= 1 << 6)
    # ImGuiTestRunFlags_CommandLine       = 1 << 7    /* original C++ signature */
    # }
    command_line = enum.auto()  # (= 1 << 7)

# -------------------------------------------------------------------------
# Functions
# -------------------------------------------------------------------------

# extern void         ImGuiTestEngineHook_ItemAdd(ImGuiContext* ui_ctx, ImGuiID id, const ImRect& bb, const ImGuiLastItemData* item_data);    /* original C++ signature */
def hook_item_add(
    ui_ctx: Context, id_: ID, bb: ImRect, item_data: LastItemData
) -> None:
    """Hooks for core imgui/ library (generally called via macros)
    (private API)
    """
    pass

# extern void         ImGuiTestEngineHook_Log(ImGuiContext* ui_ctx, const char* fmt, ...);    /* original C++ signature */
def hook_log(ui_ctx: Context, fmt: str) -> None:
    """(private API)"""
    pass

# extern const char*  ImGuiTestEngine_FindItemDebugLabel(ImGuiContext* ui_ctx, ImGuiID id);    /* original C++ signature */
def find_item_debug_label(ui_ctx: Context, id_: ID) -> str:
    """(private API)"""
    pass

# Functions (generally called via IM_CHECK() macros)
# IMGUI_API bool      ImGuiTestEngine_Check(const char* file, const char* func, int line, ImGuiTestCheckFlags flags, bool result, const char* expr);    /* original C++ signature */
def check(
    file: str, func: str, line: int, flags: TestCheckFlags, result: bool, expr: str
) -> bool:
    pass

# IMGUI_API bool      ImGuiTestEngine_CheckStrOp(const char* file, const char* func, int line, ImGuiTestCheckFlags flags, const char* op, const char* lhs_var, const char* lhs_value, const char* rhs_var, const char* rhs_value, bool* out_result);    /* original C++ signature */
def check_str_op(
    file: str,
    func: str,
    line: int,
    flags: TestCheckFlags,
    op: str,
    lhs_var: str,
    lhs_value: str,
    rhs_var: str,
    rhs_value: str,
    out_result: bool,
) -> Tuple[bool, bool]:
    pass

# IMGUI_API bool      ImGuiTestEngine_Error(const char* file, const char* func, int line, ImGuiTestCheckFlags flags, const char* fmt, ...);    /* original C++ signature */
def error(file: str, func: str, line: int, flags: TestCheckFlags, fmt: str) -> bool:
    pass

# IMGUI_API void      ImGuiTestEngine_AssertLog(const char* expr, const char* file, const char* function, int line);    /* original C++ signature */
def assert_log(expr: str, file: str, function: str, line: int) -> None:
    pass

# -------------------------------------------------------------------------
# ImGuiTestEngine API
# -------------------------------------------------------------------------

# Functions: Initialization
# IMGUI_API ImGuiTestEngine*    ImGuiTestEngine_CreateContext();                                          /* original C++ signature */
def create_context() -> TestEngine:
    """Create test engine"""
    pass

# IMGUI_API void                ImGuiTestEngine_DestroyContext(ImGuiTestEngine* engine);                  /* original C++ signature */
def destroy_context(engine: TestEngine) -> None:
    """Destroy test engine. Call after ImGui::DestroyContext() so test engine specific ini data gets saved."""
    pass

# IMGUI_API void                ImGuiTestEngine_Start(ImGuiTestEngine* engine, ImGuiContext* ui_ctx);     /* original C++ signature */
def start(engine: TestEngine, ui_ctx: Context) -> None:
    """Bind to a dear imgui context. Start coroutine."""
    pass

# IMGUI_API void                ImGuiTestEngine_Stop(ImGuiTestEngine* engine);                            /* original C++ signature */
def stop(engine: TestEngine) -> None:
    """Stop coroutine and export if any. (Unbind will lazily happen on context shutdown)"""
    pass

# IMGUI_API void                ImGuiTestEngine_PostSwap(ImGuiTestEngine* engine);                        /* original C++ signature */
def post_swap(engine: TestEngine) -> None:
    """Call every frame after framebuffer swap, will process screen capture and call test_io.ScreenCaptureFunc()"""
    pass

# IMGUI_API ImGuiTestEngineIO&  ImGuiTestEngine_GetIO(ImGuiTestEngine* engine);    /* original C++ signature */
def get_io(engine: TestEngine) -> TestEngineIO:
    pass

# IMGUI_API ImGuiTest*          ImGuiTestEngine_RegisterTest(ImGuiTestEngine* engine, const char* category, const char* name, const char* src_file = NULL, int src_line = 0);     /* original C++ signature */
def register_test(
    engine: TestEngine,
    category: str,
    name: str,
    src_file: Optional[str] = None,
    src_line: int = 0,
) -> Test:
    """Prefer calling IM_REGISTER_TEST()"""
    pass

# Functions: Main
# IMGUI_API void                ImGuiTestEngine_QueueTest(ImGuiTestEngine* engine, ImGuiTest* test, ImGuiTestRunFlags run_flags = 0);    /* original C++ signature */
def queue_test(engine: TestEngine, test: Test, run_flags: TestRunFlags = 0) -> None:
    pass

# IMGUI_API void                ImGuiTestEngine_QueueTests(ImGuiTestEngine* engine, ImGuiTestGroup group, const char* filter = NULL, ImGuiTestRunFlags run_flags = 0);    /* original C++ signature */
def queue_tests(
    engine: TestEngine,
    group: TestGroup,
    filter: Optional[str] = None,
    run_flags: TestRunFlags = 0,
) -> None:
    pass

# IMGUI_API bool                ImGuiTestEngine_TryAbortEngine(ImGuiTestEngine* engine);    /* original C++ signature */
def try_abort_engine(engine: TestEngine) -> bool:
    pass

# IMGUI_API void                ImGuiTestEngine_AbortCurrentTest(ImGuiTestEngine* engine);    /* original C++ signature */
def abort_current_test(engine: TestEngine) -> None:
    pass

# Functions: Status Queries
# FIXME: Clarify API to avoid function calls vs raw bools in ImGuiTestEngineIO
# IMGUI_API bool                ImGuiTestEngine_IsTestQueueEmpty(ImGuiTestEngine* engine);    /* original C++ signature */
def is_test_queue_empty(engine: TestEngine) -> bool:
    pass

# IMGUI_API bool                ImGuiTestEngine_IsUsingSimulatedInputs(ImGuiTestEngine* engine);    /* original C++ signature */
def is_using_simulated_inputs(engine: TestEngine) -> bool:
    pass

# IMGUI_API void                ImGuiTestEngine_GetResult(ImGuiTestEngine* engine, int& count_tested, int& success_count);    /* original C++ signature */
def get_result(
    engine: TestEngine, count_tested: int, success_count: int
) -> Tuple[int, int]:
    pass

# IMGUI_API void                ImGuiTestEngine_GetTestList(ImGuiTestEngine* engine, ImVector<ImGuiTest*>* out_tests);    /* original C++ signature */
def get_test_list(engine: TestEngine, out_tests: List[Test]) -> None:
    pass

# IMGUI_API void                ImGuiTestEngine_GetTestQueue(ImGuiTestEngine* engine, ImVector<ImGuiTestRunTask>* out_tests);    /* original C++ signature */
def get_test_queue(engine: TestEngine, out_tests: List[TestRunTask]) -> None:
    pass

# Functions: Crash Handling
# Ensure past test results are properly exported even if application crash during a test.
# IMGUI_API void                ImGuiTestEngine_InstallDefaultCrashHandler();         /* original C++ signature */
def install_default_crash_handler() -> None:
    """Install default crash handler (if you don't have one)"""
    pass

# IMGUI_API void                ImGuiTestEngine_CrashHandler();                       /* original C++ signature */
def crash_handler() -> None:
    """Default crash handler, should be called from a custom crash handler if such exists"""
    pass

# -----------------------------------------------------------------------------
# IO structure to configure the test engine
# -----------------------------------------------------------------------------

class TestEngineIO:
    # -------------------------------------------------------------------------
    # Functions
    # -------------------------------------------------------------------------

    # Options: Functions
    # void*                                       SrcFileOpenUserData = NULL;    /* original C++ signature */
    src_file_open_user_data: Any = None  # (Optional) User data for SrcFileOpenFunc
    # void*                                       ScreenCaptureUserData = NULL;    /* original C++ signature */
    screen_capture_user_data: Any = None  # (Optional) User data for ScreenCaptureFunc

    # Options: Main
    # bool                        ConfigSavedSettings = true;    /* original C++ signature */
    config_saved_settings: bool = True  # Load/Save settings in main context .ini file.
    # ImGuiTestRunSpeed           ConfigRunSpeed = ImGuiTestRunSpeed_Fast;    /* original C++ signature */
    config_run_speed: TestRunSpeed = (
        TestRunSpeed_Fast  # Run tests in fast/normal/cinematic mode
    )
    # bool                        ConfigStopOnError = false;    /* original C++ signature */
    config_stop_on_error: bool = False  # Stop queued tests on test error
    # bool                        ConfigBreakOnError = false;    /* original C++ signature */
    config_break_on_error: bool = (
        False  # Break debugger on test error by calling IM_DEBUG_BREAK()
    )
    # bool                        ConfigKeepGuiFunc = false;    /* original C++ signature */
    config_keep_gui_func: bool = False  # Keep test GUI running at the end of the test
    # ImGuiTestVerboseLevel       ConfigVerboseLevel = ImGuiTestVerboseLevel_Warning;    /* original C++ signature */
    config_verbose_level: TestVerboseLevel = TestVerboseLevel_Warning
    # ImGuiTestVerboseLevel       ConfigVerboseLevelOnError = ImGuiTestVerboseLevel_Info;    /* original C++ signature */
    config_verbose_level_on_error: TestVerboseLevel = TestVerboseLevel_Info
    # bool                        ConfigLogToTTY = false;    /* original C++ signature */
    config_log_to_tty: bool = False
    # bool                        ConfigLogToDebugger = false;    /* original C++ signature */
    config_log_to_debugger: bool = False
    # bool                        ConfigRestoreFocusAfterTests = true;    /* original C++ signature */
    config_restore_focus_after_tests: bool = (
        True  # Restore focus back after running tests
    )
    # bool                        ConfigCaptureEnabled = true;    /* original C++ signature */
    config_capture_enabled: bool = True  # Master enable flags for capturing and saving captures. Disable to avoid e.g. lengthy saving of large PNG files.
    # bool                        ConfigCaptureOnError = false;    /* original C++ signature */
    config_capture_on_error: bool = False
    # bool                        ConfigNoThrottle = false;    /* original C++ signature */
    config_no_throttle: bool = (
        False  # Disable vsync for performance measurement or fast test running
    )
    # bool                        ConfigMouseDrawCursor = true;    /* original C++ signature */
    config_mouse_draw_cursor: bool = (
        True  # Enable drawing of Dear ImGui software mouse cursor when running tests
    )
    # float                       ConfigFixedDeltaTime = 0.0f;    /* original C++ signature */
    config_fixed_delta_time: float = (
        0.0  # Use fixed delta time instead of calculating it from wall clock
    )
    # int                         PerfStressAmount = 1;    /* original C++ signature */
    perf_stress_amount: int = (
        1  # Integer to scale the amount of items submitted in test
    )

    # Options: Speed of user simulation
    # float                       MouseSpeed = 600.0f;    /* original C++ signature */
    mouse_speed: float = (
        600.0  # Mouse speed (pixel/second) when not running in fast mode
    )
    # float                       MouseWobble = 0.25f;    /* original C++ signature */
    mouse_wobble: float = 0.25  # (0.0..1.0) How much wobble to apply to the mouse (pixels per pixel of move distance) when not running in fast mode
    # float                       ScrollSpeed = 1400.0f;    /* original C++ signature */
    scroll_speed: float = (
        1400.0  # Scroll speed (pixel/second) when not running in fast mode
    )
    # float                       TypingSpeed = 20.0f;    /* original C++ signature */
    typing_speed: float = (
        20.0  # Char input speed (characters/second) when not running in fast mode
    )
    # float                       ActionDelayShort = 0.15f;    /* original C++ signature */
    action_delay_short: float = 0.15  # Time between short actions
    # float                       ActionDelayStandard = 0.40f;    /* original C++ signature */
    action_delay_standard: float = 0.40  # Time between most actions

    # Options: Screen/video capture

    # Options: Watchdog. Set values to FLT_MAX to disable.
    # Interactive GUI applications that may be slower tend to use higher values.
    # float                       ConfigWatchdogWarning = 30.0f;    /* original C++ signature */
    config_watchdog_warning: float = (
        30.0  # Warn when a test exceed this time (in second)
    )
    # float                       ConfigWatchdogKillTest = 60.0f;    /* original C++ signature */
    config_watchdog_kill_test: float = (
        60.0  # Attempt to stop running a test when exceeding this time (in second)
    )
    # float                       ConfigWatchdogKillApp = FLT_MAX;    /* original C++ signature */
    config_watchdog_kill_app: float = (
        sys.float_info.max
    )  # Stop application when exceeding this time (in second)

    # Options: Export
    # While you can manually call ImGuiTestEngine_Export(), registering filename/format here ensure the crash handler will always export if application crash.
    # const char*                 ExportResultsFilename = NULL;    /* original C++ signature */
    export_results_filename: str = None

    # Options: Sanity Checks
    # bool                        CheckDrawDataIntegrity = false;    /* original C++ signature */
    check_draw_data_integrity: bool = False  # Check ImDrawData integrity (buffer count, etc.). Currently cheap but may become a slow operation.

    # -------------------------------------------------------------------------
    # Output
    # -------------------------------------------------------------------------

    # Output: State of test engine
    # bool                        IsRunningTests = false;    /* original C++ signature */
    is_running_tests: bool = False
    # bool                        IsRequestingMaxAppSpeed = false;    /* original C++ signature */
    is_requesting_max_app_speed: bool = False  # When running in fast mode: request app to skip vsync or even skip rendering if it wants
    # bool                        IsCapturing = false;    /* original C++ signature */
    is_capturing: bool = False  # Capture is in progress
    # ImGuiTestEngineIO(bool ConfigSavedSettings = true, ImGuiTestRunSpeed ConfigRunSpeed = ImGuiTestRunSpeed_Fast, bool ConfigStopOnError = false, bool ConfigBreakOnError = false, bool ConfigKeepGuiFunc = false, ImGuiTestVerboseLevel ConfigVerboseLevel = ImGuiTestVerboseLevel_Warning, ImGuiTestVerboseLevel ConfigVerboseLevelOnError = ImGuiTestVerboseLevel_Info, bool ConfigLogToTTY = false, bool ConfigLogToDebugger = false, bool ConfigRestoreFocusAfterTests = true, bool ConfigCaptureEnabled = true, bool ConfigCaptureOnError = false, bool ConfigNoThrottle = false, bool ConfigMouseDrawCursor = true, float ConfigFixedDeltaTime = 0.0f, int PerfStressAmount = 1, float MouseSpeed = 600.0f, float MouseWobble = 0.25f, float ScrollSpeed = 1400.0f, float TypingSpeed = 20.0f, float ActionDelayShort = 0.15f, float ActionDelayStandard = 0.40f, float ConfigWatchdogWarning = 30.0f, float ConfigWatchdogKillTest = 60.0f, float ConfigWatchdogKillApp = FLT_MAX, bool CheckDrawDataIntegrity = false, bool IsRunningTests = false, bool IsRequestingMaxAppSpeed = false, bool IsCapturing = false);    /* original C++ signature */
    def __init__(
        self,
        config_saved_settings: bool = True,
        config_run_speed: TestRunSpeed = TestRunSpeed_Fast,
        config_stop_on_error: bool = False,
        config_break_on_error: bool = False,
        config_keep_gui_func: bool = False,
        config_verbose_level: TestVerboseLevel = TestVerboseLevel_Warning,
        config_verbose_level_on_error: TestVerboseLevel = TestVerboseLevel_Info,
        config_log_to_tty: bool = False,
        config_log_to_debugger: bool = False,
        config_restore_focus_after_tests: bool = True,
        config_capture_enabled: bool = True,
        config_capture_on_error: bool = False,
        config_no_throttle: bool = False,
        config_mouse_draw_cursor: bool = True,
        config_fixed_delta_time: float = 0.0,
        perf_stress_amount: int = 1,
        mouse_speed: float = 600.0,
        mouse_wobble: float = 0.25,
        scroll_speed: float = 1400.0,
        typing_speed: float = 20.0,
        action_delay_short: float = 0.15,
        action_delay_standard: float = 0.40,
        config_watchdog_warning: float = 30.0,
        config_watchdog_kill_test: float = 60.0,
        config_watchdog_kill_app: float = sys.float_info.max,
        check_draw_data_integrity: bool = False,
        is_running_tests: bool = False,
        is_requesting_max_app_speed: bool = False,
        is_capturing: bool = False,
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# -------------------------------------------------------------------------
# ImGuiTestItemInfo
# -------------------------------------------------------------------------

class TestItemInfo:
    """Information about a given item or window, result of an ItemInfo() or WindowInfo() query"""

    # int                         TimestampMain = -1;    /* original C++ signature */
    timestamp_main: int = -1  # Timestamp of main result (all fields)
    # int                         TimestampStatus = -1;    /* original C++ signature */
    timestamp_status: int = -1  # Timestamp of StatusFlags
    # ImGuiID                     ID = 0;    /* original C++ signature */
    id_: ID = 0  # Item ID
    # ImGuiID                     ParentID = 0;    /* original C++ signature */
    parent_id: ID = 0  # Item Parent ID (value at top of the ID stack)
    # ImGuiWindow*                Window = NULL;    /* original C++ signature */
    window: Window = None  # Item Window
    # ImRect                      RectFull = ImRect();    /* original C++ signature */
    rect_full: ImRect = ImRect()  # Item Rectangle
    # ImRect                      RectClipped = ImRect();    /* original C++ signature */
    rect_clipped: ImRect = (
        ImRect()
    )  # Item Rectangle (clipped with window->ClipRect at time of item submission)
    # ImGuiItemFlags              InFlags = 0;    /* original C++ signature */
    in_flags: ItemFlags = 0  # Item flags
    # ImGuiItemStatusFlags        StatusFlags = 0;    /* original C++ signature */
    status_flags: ItemStatusFlags = 0  # Item Status flags (fully updated for some items only, compare TimestampStatus to FrameCount)

    # ImGuiTestItemInfo()         { RefCount = 0; NavLayer = 0; Depth = 0; }    /* original C++ signature */
    def __init__(self) -> None:
        pass
    # bool                        IsEmpty() const         { return ID == 0; }    /* original C++ signature */
    def is_empty(self) -> bool:
        """(private API)"""
        pass

class TestItemList:
    """Result of an GatherItems() query"""

    # void                        Clear()                 { Pool.Clear(); }    /* original C++ signature */
    def clear(self) -> None:
        """(private API)"""
        pass
    # void                        Reserve(int capacity)   { Pool.Reserve(capacity); }    /* original C++ signature */
    def reserve(self, capacity: int) -> None:
        """(private API)"""
        pass
    # int                         GetSize() const         { return Pool.GetMapSize(); }    /* original C++ signature */
    def get_size(self) -> int:
        """(private API)"""
        pass
    # const ImGuiTestItemInfo*    GetByIndex(int n)       { return Pool.GetByIndex(n); }    /* original C++ signature */
    def get_by_index(self, n: int) -> TestItemInfo:
        """(private API)"""
        pass
    # const ImGuiTestItemInfo*    GetByID(ImGuiID id)     { return Pool.GetByKey(id); }    /* original C++ signature */
    def get_by_id(self, id_: ID) -> TestItemInfo:
        """(private API)"""
        pass
    # For range-for
    # size_t                      size() const            { return (size_t)Pool.GetMapSize(); }    /* original C++ signature */
    def size(self) -> int:
        """(private API)"""
        pass
    # const ImGuiTestItemInfo*    begin() const           { return Pool.Buf.begin(); }    /* original C++ signature */
    def begin(self) -> TestItemInfo:
        """(private API)"""
        pass
    # const ImGuiTestItemInfo*    end() const             { return Pool.Buf.end(); }    /* original C++ signature */
    def end(self) -> TestItemInfo:
        """(private API)"""
        pass
    # const ImGuiTestItemInfo*    operator[] (size_t n)   { return &Pool.Buf[(int)n]; }    /* original C++ signature */
    def __getitem__(self, n: int) -> TestItemInfo:
        """(private API)"""
        pass
    # ImGuiTestItemList();    /* original C++ signature */
    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

# -------------------------------------------------------------------------
# ImGuiTestLog: store textual output of one given Test.
# -------------------------------------------------------------------------

class TestLogLineInfo:
    # ImGuiTestVerboseLevel           Level;    /* original C++ signature */
    level: TestVerboseLevel
    # int                             LineOffset;    /* original C++ signature */
    line_offset: int
    # ImGuiTestLogLineInfo(ImGuiTestVerboseLevel Level = ImGuiTestVerboseLevel(), int LineOffset = int());    /* original C++ signature */
    def __init__(
        self, level: TestVerboseLevel = TestVerboseLevel(), line_offset: int = int()
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

class TestLog:
    # ImGuiTextBuffer                 Buffer;    /* original C++ signature */
    buffer: TextBuffer

    # ImGuiTestLog() {}    /* original C++ signature */
    def __init__(self) -> None:
        """Functions"""
        pass
    # bool    IsEmpty() const         { return Buffer.empty(); }    /* original C++ signature */
    def is_empty(self) -> bool:
        """(private API)"""
        pass
    # void    Clear();    /* original C++ signature */
    def clear(self) -> None:
        """(private API)"""
        pass
    # int     ExtractLinesForVerboseLevels(ImGuiTestVerboseLevel level_min, ImGuiTestVerboseLevel level_max, ImGuiTextBuffer* out_buffer);    /* original C++ signature */
    def extract_lines_for_verbose_levels(
        self,
        level_min: TestVerboseLevel,
        level_max: TestVerboseLevel,
        out_buffer: TextBuffer,
    ) -> int:
        """Extract log contents filtered per log-level.
         Output:
         - If 'buffer != None': all extracted lines are appended to 'buffer'. Use 'buffer->c_str()' on your side to obtain the text.
         - Return value: number of lines extracted (should be equivalent to number of '\n' inside buffer->c_str()).
         - You may call the function with buffer == None to only obtain a count without getting the data.
         Verbose levels are inclusive:
         - To get ONLY Error:                     Use level_min == ImGuiTestVerboseLevel_Error, level_max = ImGuiTestVerboseLevel_Error
         - To get ONLY Error and Warnings:        Use level_min == ImGuiTestVerboseLevel_Error, level_max = ImGuiTestVerboseLevel_Warning
         - To get All Errors, Warnings, Debug...  Use level_min == ImGuiTestVerboseLevel_Error, level_max = ImGuiTestVerboseLevel_Trace
        (private API)
        """
        pass
    # void    UpdateLineOffsets(ImGuiTestEngineIO* engine_io, ImGuiTestVerboseLevel level, const char* start);    /* original C++ signature */
    def update_line_offsets(
        self, engine_io: TestEngineIO, level: TestVerboseLevel, start: str
    ) -> None:
        """[Internal]
        (private API)
        """
        pass

# -------------------------------------------------------------------------
# ImGuiTest
# -------------------------------------------------------------------------

# Wraps a placement new of a given type (where 'buffer' is the allocated memory)

class Test:
    """Storage for one test"""

    # Test Definition
    # ImGuiTestGroup                  Group = ImGuiTestGroup_Unknown;    /* original C++ signature */
    group: TestGroup = TestGroup_Unknown  # Coarse groups: 'Tests' or 'Perf'
    # int                             SourceLine = 0;    /* original C++ signature */
    source_line: int = 0  # __LINE__
    # int                             SourceLineEnd = 0;    /* original C++ signature */
    source_line_end: int = 0  # Calculated by ImGuiTestEngine_StartCalcSourceLineEnds()
    # int                             ArgVariant = 0;    /* original C++ signature */
    arg_variant: int = 0  # User parameter. Generally we use it to run variations of a same test by sharing GuiFunc/TestFunc
    # ImGuiTestFlags                  Flags = ImGuiTestFlags_None;    /* original C++ signature */
    flags: TestFlags = TestFlags_None  # See ImGuiTestFlags_
    # Function_TestGui     GuiFunc = NULL;    /* original C++ signature */
    gui_func: Function_TestGui = None  # GUI function (optional if your test are running over an existing GUI application)
    # Function_TestRunner    TestFunc = NULL;    /* original C++ signature */
    test_func: Function_TestRunner = None  # Test function
    # void*                           UserData = NULL;    /* original C++ signature */
    user_data: Any = None  # General purpose user data (if assigning capturing lambdas on GuiFunc/TestFunc you may not need to se this)

    # Test Status
    # ImGuiTestStatus                 Status = ImGuiTestStatus_Unknown;    /* original C++ signature */
    status: TestStatus = TestStatus_Unknown
    # ImGuiTestLog                    TestLog;    /* original C++ signature */
    test_log: TestLog
    # ImU64                           StartTime = 0;    /* original C++ signature */
    start_time: ImU64 = 0
    # ImU64                           EndTime = 0;    /* original C++ signature */
    end_time: ImU64 = 0
    # int                             GuiFuncLastFrame = -1;    /* original C++ signature */
    gui_func_last_frame: int = -1

    # User variables (which are instantiated when running the test)
    # Setup after test registration with SetVarsDataType<>(), access instance during test with GetVars<>().
    # This is mostly useful to communicate between GuiFunc and TestFunc. If you don't use both you may not want to use it!
    # size_t                          VarsSize = 0;    /* original C++ signature */
    vars_size: int = 0
    # void*                           VarsPostConstructorUserFn = NULL;    /* original C++ signature */
    vars_post_constructor_user_fn: Any = None

    # ImGuiTest() {}    /* original C++ signature */
    def __init__(self) -> None:
        """Functions"""
        pass

class TestRunTask:
    """Stored in test queue"""

    # ImGuiTest*          Test = NULL;    /* original C++ signature */
    test: Test = None
    # ImGuiTestRunFlags   RunFlags = ImGuiTestRunFlags_None;    /* original C++ signature */
    run_flags: TestRunFlags = TestRunFlags_None
    # ImGuiTestRunTask(ImGuiTestRunFlags RunFlags = ImGuiTestRunFlags_None);    /* original C++ signature */
    def __init__(self, run_flags: TestRunFlags = TestRunFlags_None) -> None:
        """Auto-generated default constructor with named params"""
        pass

# -------------------------------------------------------------------------
####################    </generated_from:imgui_te_engine.h>    ####################


####################    <generated_from:imgui_te_context.h>    ####################
# dear imgui test engine
# (context when a running test + end user automation API)
# This is the main (if not only) interface that your Tests will be using.

#
#
# Index of this file:
# // [SECTION] Header mess, warnings
# // [SECTION] Forward declarations
# // [SECTION] ImGuiTestRef
# // [SECTION] Helper keys
# // [SECTION] ImGuiTestContext related Flags/Enumerations
# // [SECTION] ImGuiTestGenericVars, ImGuiTestGenericItemStatus
# // [SECTION] ImGuiTestContext
# // [SECTION] Debugging macros: IM_SUSPEND_TESTFUNC()
# // [SECTION] Testing/Checking macros: IM_CHECK(), IM_ERRORF() etc.
#
#

# -------------------------------------------------------------------------
# [SECTION] Header mess, warnings
# -------------------------------------------------------------------------

# Undo some of the damage done by <windows.h>

# -------------------------------------------------------------------------
# [SECTION] Forward declarations
# -------------------------------------------------------------------------

# This file

# External: imgui

# External: test engine

# -------------------------------------------------------------------------
# [SECTION] ImGuiTestRef
# -------------------------------------------------------------------------

class TestRef:
    """Weak reference to an Item/Window given an hashed ID _or_ a string path ID.
    This is most often passed as argument to function and generally has a very short lifetime.
    Documentation: https://github.com/ocornut/imgui_test_engine/wiki/Named-References
    (SUGGESTION: add those constructors to "VA Step Filter" (Visual Assist) or a .natstepfilter file (Visual Studio) so they are skipped by F11 (StepInto)
    """

    # ImGuiID         ID;    /* original C++ signature */
    id_: ID  # Pre-hashed ID

    # ImGuiTestRef()                  { ID = 0; Path = Str(""); }    /* original C++ signature */
    @overload
    def __init__(self) -> None:
        pass
    # ImGuiTestRef(ImGuiID id)        { ID = id; Path = Str(""); }    /* original C++ signature */
    @overload
    def __init__(self, id_: ID) -> None:
        pass
    # ImGuiTestRef(const char* path)  { ID = 0; Path = Str(path); }    /* original C++ signature */
    @overload
    def __init__(self, path: str) -> None:
        pass
    # bool IsEmpty() const            { return ID == 0 && Path.length() == 0; }    /* original C++ signature */
    def is_empty(self) -> bool:
        """(private API)"""
        pass

class TestRefDesc:
    """Debug helper to output a string showing the Path, ID or Debug Label based on what is available (some items only have ID as we couldn't find/store a Path)
    (The size is arbitrary, this is only used for logging info the user/debugger)
    """

    # const char* c_str()             { return Buf; }    /* original C++ signature */
    def c_str(self) -> str:
        """(private API)"""
        pass
    # ImGuiTestRefDesc(const ImGuiTestRef& ref, const ImGuiTestItemInfo* item);    /* original C++ signature */
    def __init__(self, ref: TestRef, item: TestItemInfo) -> None:
        pass

# -------------------------------------------------------------------------
# [SECTION] ImGuiTestContext related Flags/Enumerations
# -------------------------------------------------------------------------

class TestAction(enum.Enum):
    """Named actions. Generally you will call the named helpers e.g. ItemClick(). This is used by shared/low-level functions such as ItemAction()."""

    # ImGuiTestAction_Unknown = 0,    /* original C++ signature */
    unknown = enum.auto()  # (= 0)
    # ImGuiTestAction_Hover,              /* original C++ signature */
    hover = enum.auto()  # (= 1)  # Move mouse
    # ImGuiTestAction_Click,              /* original C++ signature */
    click = enum.auto()  # (= 2)  # Move mouse and click
    # ImGuiTestAction_DoubleClick,        /* original C++ signature */
    double_click = enum.auto()  # (= 3)  # Move mouse and double-click
    # ImGuiTestAction_Check,              /* original C++ signature */
    check = (
        enum.auto()
    )  # (= 4)  # Check item if unchecked (Checkbox, MenuItem or any widget reporting ImGuiItemStatusFlags_Checkable)
    # ImGuiTestAction_Uncheck,            /* original C++ signature */
    uncheck = enum.auto()  # (= 5)  # Uncheck item if checked
    # ImGuiTestAction_Open,               /* original C++ signature */
    open = (
        enum.auto()
    )  # (= 6)  # Open item if closed (TreeNode, BeginMenu or any widget reporting ImGuiItemStatusFlags_Openable)
    # ImGuiTestAction_Close,              /* original C++ signature */
    close = enum.auto()  # (= 7)  # Close item if opened
    # ImGuiTestAction_Input,              /* original C++ signature */
    input = (
        enum.auto()
    )  # (= 8)  # Start text inputing into a field (e.g. CTRL+Click on Drags/Slider, click on InputText etc.)
    # ImGuiTestAction_NavActivate,        /* original C++ signature */
    nav_activate = enum.auto()  # (= 9)  # Activate item with navigation
    # ImGuiTestAction_COUNT    /* original C++ signature */
    # }
    count = enum.auto()  # (= 10)

class TestOpFlags_(enum.Enum):
    """Generic flags for many ImGuiTestContext functions"""

    # ImGuiTestOpFlags_None               = 0,    /* original C++ signature */
    none = enum.auto()  # (= 0)
    # ImGuiTestOpFlags_NoCheckHoveredId   = 1 << 1,       /* original C++ signature */
    no_check_hovered_id = (
        enum.auto()
    )  # (= 1 << 1)  # Don't check for HoveredId after aiming for a widget. A few situations may want this: while e.g. dragging or another items prevents hovering, or for items that don't use ItemHoverable()
    # ImGuiTestOpFlags_NoError            = 1 << 2,       /* original C++ signature */
    no_error = (
        enum.auto()
    )  # (= 1 << 2)  # Don't abort/error e.g. if the item cannot be found or the operation doesn't succeed.
    # ImGuiTestOpFlags_NoFocusWindow      = 1 << 3,       /* original C++ signature */
    no_focus_window = (
        enum.auto()
    )  # (= 1 << 3)  # Don't focus window when aiming at an item
    # ImGuiTestOpFlags_NoAutoUncollapse   = 1 << 4,       /* original C++ signature */
    no_auto_uncollapse = (
        enum.auto()
    )  # (= 1 << 4)  # Disable automatically uncollapsing windows (useful when specifically testing Collapsing behaviors)
    # ImGuiTestOpFlags_NoAutoOpenFullPath = 1 << 5,       /* original C++ signature */
    no_auto_open_full_path = (
        enum.auto()
    )  # (= 1 << 5)  # Disable automatically opening intermediaries (e.g. ItemClick("Hello/OK") will automatically first open "Hello" if "OK" isn't found. Only works if ref is a string path.
    # ImGuiTestOpFlags_IsSecondAttempt    = 1 << 6,       /* original C++ signature */
    is_second_attempt = (
        enum.auto()
    )  # (= 1 << 6)  # Used by recursing functions to indicate a second attempt
    # ImGuiTestOpFlags_MoveToEdgeL        = 1 << 7,       /* original C++ signature */
    move_to_edge_l = (
        enum.auto()
    )  # (= 1 << 7)  # Simple Dumb aiming helpers to test widget that care about clicking position. May need to replace will better functionalities.
    # ImGuiTestOpFlags_MoveToEdgeR        = 1 << 8,    /* original C++ signature */
    move_to_edge_r = enum.auto()  # (= 1 << 8)
    # ImGuiTestOpFlags_MoveToEdgeU        = 1 << 9,    /* original C++ signature */
    move_to_edge_u = enum.auto()  # (= 1 << 9)
    # ImGuiTestOpFlags_MoveToEdgeD        = 1 << 10,    /* original C++ signature */
    # }
    move_to_edge_d = enum.auto()  # (= 1 << 10)

class TestActionFilter:
    """Advanced filtering for ItemActionAll()"""

    # int                     MaxDepth;    /* original C++ signature */
    max_depth: int
    # int                     MaxPasses;    /* original C++ signature */
    max_passes: int
    # const int*              MaxItemCountPerDepth;    /* original C++ signature */
    max_item_count_per_depth: int
    # ImGuiItemStatusFlags    RequireAllStatusFlags;    /* original C++ signature */
    require_all_status_flags: ItemStatusFlags
    # ImGuiItemStatusFlags    RequireAnyStatusFlags;    /* original C++ signature */
    require_any_status_flags: ItemStatusFlags

    # ImGuiTestActionFilter() { MaxDepth = -1; MaxPasses = -1; MaxItemCountPerDepth = NULL; RequireAllStatusFlags = RequireAnyStatusFlags = 0; }    /* original C++ signature */
    def __init__(self) -> None:
        pass

# -------------------------------------------------------------------------
# [SECTION] ImGuiTestGenericVars, ImGuiTestGenericItemStatus
# -------------------------------------------------------------------------

class TestGenericItemStatus:
    """Helper struct to store various query-able state of an item.
    This facilitate interactions between GuiFunc and TestFunc, since those state are frequently used.
    """

    # int     RetValue;    /* original C++ signature */
    ret_value: int  # return value
    # int     Hovered;    /* original C++ signature */
    hovered: int  # result of IsItemHovered()
    # int     Active;    /* original C++ signature */
    active: int  # result of IsItemActive()
    # int     Focused;    /* original C++ signature */
    focused: int  # result of IsItemFocused()
    # int     Clicked;    /* original C++ signature */
    clicked: int  # result of IsItemClicked()
    # int     Visible;    /* original C++ signature */
    visible: int  # result of IsItemVisible()
    # int     Edited;    /* original C++ signature */
    edited: int  # result of IsItemEdited()
    # int     Activated;    /* original C++ signature */
    activated: int  # result of IsItemActivated()
    # int     Deactivated;    /* original C++ signature */
    deactivated: int  # result of IsItemDeactivated()
    # int     DeactivatedAfterEdit;    /* original C++ signature */
    deactivated_after_edit: int  # result of IsItemDeactivatedAfterEdit()

    # ImGuiTestGenericItemStatus()        { Clear(); }    /* original C++ signature */
    def __init__(self) -> None:
        pass
    # void Clear()                        { memset(this, 0, sizeof(*this)); }    /* original C++ signature */
    def clear(self) -> None:
        """(private API)"""
        pass
    # void QuerySet(bool ret_val = false) { Clear(); QueryInc(ret_val); }    /* original C++ signature */
    def query_set(self, ret_val: bool = False) -> None:
        """(private API)"""
        pass
    # void QueryInc(bool ret_val = false) { RetValue += ret_val; Hovered += ImGui::IsItemHovered(); Active += ImGui::IsItemActive(); Focused += ImGui::IsItemFocused(); Clicked += ImGui::IsItemClicked(); Visible += ImGui::IsItemVisible(); Edited += ImGui::IsItemEdited(); Activated += ImGui::IsItemActivated(); Deactivated += ImGui::IsItemDeactivated(); DeactivatedAfterEdit += ImGui::IsItemDeactivatedAfterEdit(); }    /* original C++ signature */
    def query_inc(self, ret_val: bool = False) -> None:
        """(private API)"""
        pass

class TestGenericVars:
    """Generic structure with various storage fields.
    This is useful for tests to quickly share data between GuiFunc and TestFunc without creating custom data structure.
    If those fields are not enough: using test->SetVarsDataType<>() + ctx->GetVars<>() it is possible to store custom data.
    """

    # Generic storage with a bit of semantic to make user/test code look neater
    # int                     Step;    /* original C++ signature */
    step: int
    # int                     Count;    /* original C++ signature */
    count: int
    # ImGuiID                 DockId;    /* original C++ signature */
    dock_id: ID
    # ImGuiWindowFlags        WindowFlags;    /* original C++ signature */
    window_flags: WindowFlags
    # ImGuiTableFlags         TableFlags;    /* original C++ signature */
    table_flags: TableFlags
    # ImGuiPopupFlags         PopupFlags;    /* original C++ signature */
    popup_flags: PopupFlags
    # ImGuiTestGenericItemStatus  Status;    /* original C++ signature */
    status: TestGenericItemStatus
    # bool                    ShowWindow1,     /* original C++ signature */
    show_window1: bool
    # ShowWindow2;    /* original C++ signature */
    show_window2: bool
    # bool                    UseClipper;    /* original C++ signature */
    use_clipper: bool
    # bool                    UseViewports;    /* original C++ signature */
    use_viewports: bool
    # float                   Width;    /* original C++ signature */
    width: float
    # ImVec2                  Pos;    /* original C++ signature */
    pos: ImVec2
    # ImVec2                  Size;    /* original C++ signature */
    size: ImVec2
    # ImVec2                  Pivot;    /* original C++ signature */
    pivot: ImVec2
    # ImVec4                  Color1,     /* original C++ signature */
    color1: ImVec4
    # Color2;    /* original C++ signature */
    color2: ImVec4

    # Generic unnamed storage
    # int                     Int1,     /* original C++ signature */
    int1: int
    # Int2,     /* original C++ signature */
    int2: int
    # IntArray[10];    /* original C++ signature */
    int_array: np.ndarray  # ndarray[type=int, size=10]
    # float                   Float1,     /* original C++ signature */
    float1: float
    # Float2,     /* original C++ signature */
    float2: float
    # FloatArray[10];    /* original C++ signature */
    float_array: np.ndarray  # ndarray[type=float, size=10]
    # bool                    Bool1,     /* original C++ signature */
    bool1: bool
    # Bool2,     /* original C++ signature */
    bool2: bool
    # BoolArray[10];    /* original C++ signature */
    bool_array: np.ndarray  # ndarray[type=bool, size=10]
    # ImGuiID                 Id,     /* original C++ signature */
    id_: ID
    # IdArray[10];    /* original C++ signature */
    id_array: np.ndarray  # ndarray[type=ImGuiID, size=10]

    # ImGuiTestGenericVars()  { Clear(); }    /* original C++ signature */
    def __init__(self) -> None:
        pass
    # void Clear()            { memset(this, 0, sizeof(*this)); }    /* original C++ signature */
    def clear(self) -> None:
        """(private API)"""
        pass

# -------------------------------------------------------------------------
# [SECTION] ImGuiTestContext
# Context for a running ImGuiTest
# This is the interface that most tests will interact with.
# -------------------------------------------------------------------------

class TestContext:
    # User variables
    # ImGuiTestGenericVars    GenericVars;    /* original C++ signature */
    generic_vars: TestGenericVars
    # void*                   UserVars = NULL;    /* original C++ signature */
    user_vars: Any = (
        None  # Access using ctx->GetVars<Type>(). Setup with test->SetVarsDataType<>().
    )

    # Public fields
    # ImGuiContext*           UiContext = NULL;    /* original C++ signature */
    ui_context: Context = None  # UI context
    # ImGuiTestEngineIO*      EngineIO = NULL;    /* original C++ signature */
    engine_io: TestEngineIO = None  # Test Engine IO/settings
    # ImGuiTest*              Test = NULL;    /* original C++ signature */
    test: Test = None  # Test currently running
    # ImGuiTestOpFlags        OpFlags = ImGuiTestOpFlags_None;    /* original C++ signature */
    op_flags: TestOpFlags = TestOpFlags_None  # Flags affecting all operation (supported: ImGuiTestOpFlags_NoAutoUncollapse)
    # int                     PerfStressAmount = 0;    /* original C++ signature */
    perf_stress_amount: int = 0  # Convenience copy of engine->IO.PerfStressAmount
    # int                     FrameCount = 0;    /* original C++ signature */
    frame_count: int = 0  # Test frame count (restarts from zero every time)
    # int                     FirstTestFrameCount = 0;    /* original C++ signature */
    first_test_frame_count: int = 0  # First frame where TestFunc is running (after warm-up frame). This is generally -1 or 0 depending on whether we have warm up enabled
    # bool                    FirstGuiFrame = false;    /* original C++ signature */
    first_gui_frame: bool = False
    # bool                    HasDock = false;    /* original C++ signature */
    has_dock: bool = False  # #ifdef IMGUI_HAS_DOCK expressed in an easier to test value

    # -------------------------------------------------------------------------
    # [Internal Fields]
    # -------------------------------------------------------------------------

    # ImGuiTestEngine*        Engine = NULL;    /* original C++ signature */
    engine: TestEngine = None
    # ImGuiTestInputs*        Inputs = NULL;    /* original C++ signature */
    inputs: TestInputs = None
    # ImGuiTestRunFlags       RunFlags = ImGuiTestRunFlags_None;    /* original C++ signature */
    run_flags: TestRunFlags = TestRunFlags_None
    # ImGuiTestActiveFunc     ActiveFunc = ImGuiTestActiveFunc_None;    /* original C++ signature */
    active_func: TestActiveFunc = TestActiveFunc_None  # None/GuiFunc/TestFunc
    # double                  RunningTime = 0.0;    /* original C++ signature */
    running_time: float = 0.0  # Amount of wall clock time the Test has been running. Used by safety watchdog.
    # int                     ActionDepth = 0;    /* original C++ signature */
    action_depth: int = 0  # Nested depth of ctx-> function calls (used to decorate log)
    # int                     CaptureCounter = 0;    /* original C++ signature */
    capture_counter: int = 0  # Number of captures
    # int                     ErrorCounter = 0;    /* original C++ signature */
    error_counter: int = 0  # Number of errors (generally this maxxes at 1 as most functions will early out)
    # bool                    Abort = false;    /* original C++ signature */
    abort: bool = False
    # double                  PerfRefDt = -1.0;    /* original C++ signature */
    perf_ref_dt: float = -1.0
    # int                     PerfIterations = 400;    /* original C++ signature */
    perf_iterations: int = 400  # Number of frames for PerfCapture() measurements
    # ImGuiID                 RefID = 0;    /* original C++ signature */
    ref_id: ID = 0  # Reference ID over which all named references are based
    # ImGuiID                 RefWindowID = 0;    /* original C++ signature */
    ref_window_id: ID = 0  # ID of a window that contains RefID item
    # ImGuiInputSource        InputMode = ImGuiInputSource_Mouse;    /* original C++ signature */
    input_mode: InputSource = (
        InputSource_Mouse  # Prefer interacting with mouse/keyboard/gamepad
    )
    # ImGuiTestItemInfo       DummyItemInfoNull;    /* original C++ signature */
    dummy_item_info_null: TestItemInfo  # Storage for ItemInfoNull()
    # bool                    CachedLinesPrintedToTTY = false;    /* original C++ signature */
    cached_lines_printed_to_tty: bool = False

    # -------------------------------------------------------------------------
    # Public API
    # -------------------------------------------------------------------------

    # Main control
    # void        Finish();    /* original C++ signature */
    def finish(self) -> None:
        """(private API)"""
        pass
    # void        RecoverFromUiContextErrors();    /* original C++ signature */
    def recover_from_ui_context_errors(self) -> None:
        """(private API)"""
        pass
    # Main status queries
    # bool        IsError() const             { return Test->Status == ImGuiTestStatus_Error || Abort; }    /* original C++ signature */
    def is_error(self) -> bool:
        """(private API)"""
        pass
    # bool        IsWarmUpGuiFrame() const    { return FrameCount < FirstTestFrameCount; }        /* original C++ signature */
    def is_warm_up_gui_frame(self) -> bool:
        """(private API)

        Unless test->Flags has ImGuiTestFlags_NoGuiWarmUp, we run GuiFunc() twice before running TestFunc(). Those frames are called "WarmUp" frames.
        """
        pass
    # bool        IsFirstGuiFrame() const     { return FirstGuiFrame; }    /* original C++ signature */
    def is_first_gui_frame(self) -> bool:
        """(private API)"""
        pass
    # bool        IsFirstTestFrame() const    { return FrameCount == FirstTestFrameCount; }       /* original C++ signature */
    def is_first_test_frame(self) -> bool:
        """(private API)

        First frame where TestFunc is running (after warm-up frame).
        """
        pass
    # bool        IsGuiFuncOnly() const       { return (RunFlags & ImGuiTestRunFlags_GuiFuncOnly) != 0; }    /* original C++ signature */
    def is_gui_func_only(self) -> bool:
        """(private API)"""
        pass
    # void        SetGuiFuncEnabled(bool v) { if (v) RunFlags &= ~ImGuiTestRunFlags_GuiFuncDisable; else RunFlags |= ImGuiTestRunFlags_GuiFuncDisable; }    /* original C++ signature */
    def set_gui_func_enabled(self, v: bool) -> None:
        """(private API)"""
        pass
    # Debug Control Flow
    # bool        SuspendTestFunc(const char* file = NULL, int line = 0);     /* original C++ signature */
    def suspend_test_func(self, file: Optional[str] = None, line: int = 0) -> bool:
        """(private API)

        Generally called via IM_SUSPEND_TESTFUNC
        """
        pass
    # Logging
    # void        LogEx(ImGuiTestVerboseLevel level, ImGuiTestLogFlags flags, const char* fmt, ...) ;    /* original C++ signature */
    def log_ex(self, level: TestVerboseLevel, flags: TestLogFlags, fmt: str) -> None:
        """(private API)"""
        pass
    # void        LogToTTY(ImGuiTestVerboseLevel level, const char* message, const char* message_end = NULL);    /* original C++ signature */
    def log_to_tty(
        self, level: TestVerboseLevel, message: str, message_end: Optional[str] = None
    ) -> None:
        """(private API)"""
        pass
    # void        LogToDebugger(ImGuiTestVerboseLevel level, const char* message);    /* original C++ signature */
    def log_to_debugger(self, level: TestVerboseLevel, message: str) -> None:
        """(private API)"""
        pass
    # void        LogDebug(const char* fmt, ...)      ;      /* original C++ signature */
    def log_debug(self, fmt: str) -> None:
        """(private API)

        ImGuiTestVerboseLevel_Debug or ImGuiTestVerboseLevel_Trace depending on context depth
        """
        pass
    # void        LogInfo(const char* fmt, ...)       ;      /* original C++ signature */
    def log_info(self, fmt: str) -> None:
        """(private API)

        ImGuiTestVerboseLevel_Info
        """
        pass
    # void        LogWarning(const char* fmt, ...)    ;      /* original C++ signature */
    def log_warning(self, fmt: str) -> None:
        """(private API)

        ImGuiTestVerboseLevel_Warning
        """
        pass
    # void        LogError(const char* fmt, ...)      ;      /* original C++ signature */
    def log_error(self, fmt: str) -> None:
        """(private API)

        ImGuiTestVerboseLevel_Error
        """
        pass
    # void        LogBasicUiState();    /* original C++ signature */
    def log_basic_ui_state(self) -> None:
        """(private API)"""
        pass
    # void        LogItemList(ImGuiTestItemList* list);    /* original C++ signature */
    def log_item_list(self, list: TestItemList) -> None:
        """(private API)"""
        pass
    # Yield, Timing
    # void        Yield(int count = 1);    /* original C++ signature */
    def yield_(self, count: int = 1) -> None:
        """(private API)"""
        pass
    # void        YieldUntil(int frame_count);    /* original C++ signature */
    def yield_until(self, frame_count: int) -> None:
        """(private API)"""
        pass
    # void        Sleep(float time_in_second);                /* original C++ signature */
    def sleep(self, time_in_second: float) -> None:
        """(private API)

        Sleep for a given simulation time, unless in Fast mode
        """
        pass
    # void        SleepShort();                               /* original C++ signature */
    def sleep_short(self) -> None:
        """(private API)

        Standard short delay of io.ActionDelayShort (~0.15), unless in Fast mode.
        """
        pass
    # void        SleepStandard();                            /* original C++ signature */
    def sleep_standard(self) -> None:
        """(private API)

        Standard regular delay of io.ActionDelayStandard (~0.40), unless in Fast mode.
        """
        pass
    # void        SleepNoSkip(float time_in_second, float framestep_in_second);    /* original C++ signature */
    def sleep_no_skip(self, time_in_second: float, framestep_in_second: float) -> None:
        """(private API)"""
        pass
    # Base Reference
    # - ItemClick("Window/Button")                --> click "Window/Button"
    # - SetRef("Window"), ItemClick("Button")     --> click "Window/Button"
    # - SetRef("Window"), ItemClick("/Button")    --> click "Window/Button"
    # - SetRef("Window"), ItemClick("//Button")   --> click "/Button"
    # - SetRef("//$FOCUSED"), ItemClick("Button") --> click "Button" in focused window.
    # Takes multiple frames to complete if specified ref is an item id.
    # void        SetRef(ImGuiTestRef ref);    /* original C++ signature */
    @overload
    def set_ref(self, ref: TestRef) -> None:
        """(private API)"""
        pass
    # void        SetRef(ImGuiWindow* window);     /* original C++ signature */
    @overload
    def set_ref(self, window: Window) -> None:
        """(private API)

        Shortcut to SetRef(window->Name) which works for ChildWindow (see code)
        """
        pass
    # ImGuiTestRef GetRef();    /* original C++ signature */
    def get_ref(self) -> TestRef:
        """(private API)"""
        pass
    # Windows
    # ImGuiTestItemInfo* WindowInfo(ImGuiTestRef window_ref, ImGuiTestOpFlags flags = ImGuiTestOpFlags_None);    /* original C++ signature */
    def window_info(
        self, window_ref: TestRef, flags: TestOpFlags = TestOpFlags_None
    ) -> TestItemInfo:
        """(private API)"""
        pass
    # void        WindowClose(ImGuiTestRef window_ref);    /* original C++ signature */
    def window_close(self, window_ref: TestRef) -> None:
        """(private API)"""
        pass
    # void        WindowCollapse(ImGuiTestRef window_ref, bool collapsed);    /* original C++ signature */
    def window_collapse(self, window_ref: TestRef, collapsed: bool) -> None:
        """(private API)"""
        pass
    # void        WindowFocus(ImGuiTestRef window_ref, ImGuiTestOpFlags flags = ImGuiTestOpFlags_None);    /* original C++ signature */
    def window_focus(
        self, window_ref: TestRef, flags: TestOpFlags = TestOpFlags_None
    ) -> None:
        """(private API)"""
        pass
    # void        WindowBringToFront(ImGuiTestRef window_ref, ImGuiTestOpFlags flags = ImGuiTestOpFlags_None);    /* original C++ signature */
    def window_bring_to_front(
        self, window_ref: TestRef, flags: TestOpFlags = TestOpFlags_None
    ) -> None:
        """(private API)"""
        pass
    # void        WindowMove(ImGuiTestRef window_ref, ImVec2 pos, ImVec2 pivot = ImVec2(0.0f, 0.0f), ImGuiTestOpFlags flags = ImGuiTestOpFlags_None);    /* original C++ signature */
    def window_move(
        self,
        window_ref: TestRef,
        pos: ImVec2,
        pivot: ImVec2 = ImVec2(0.0, 0.0),
        flags: TestOpFlags = TestOpFlags_None,
    ) -> None:
        """(private API)"""
        pass
    # void        WindowResize(ImGuiTestRef window_ref, ImVec2 sz);    /* original C++ signature */
    def window_resize(self, window_ref: TestRef, sz: ImVec2) -> None:
        """(private API)"""
        pass
    # bool        WindowTeleportToMakePosVisible(ImGuiTestRef window_ref, ImVec2 pos_in_window);    /* original C++ signature */
    def window_teleport_to_make_pos_visible(
        self, window_ref: TestRef, pos_in_window: ImVec2
    ) -> bool:
        """(private API)"""
        pass
    # ImGuiWindow*GetWindowByRef(ImGuiTestRef window_ref);    /* original C++ signature */
    def get_window_by_ref(self, window_ref: TestRef) -> Window:
        """(private API)"""
        pass
    # Popups
    # void        PopupCloseOne();    /* original C++ signature */
    def popup_close_one(self) -> None:
        """(private API)"""
        pass
    # void        PopupCloseAll();    /* original C++ signature */
    def popup_close_all(self) -> None:
        """(private API)"""
        pass
    # ImGuiID     PopupGetWindowID(ImGuiTestRef ref);    /* original C++ signature */
    def popup_get_window_id(self, ref: TestRef) -> ID:
        """(private API)"""
        pass
    # Get hash for a decorated ID Path.
    # Note: for windows you may use WindowInfo()
    # ImGuiID     GetID(ImGuiTestRef ref);    /* original C++ signature */
    @overload
    def get_id(self, ref: TestRef) -> ID:
        """(private API)"""
        pass
    # ImGuiID     GetID(ImGuiTestRef ref, ImGuiTestRef seed_ref);    /* original C++ signature */
    @overload
    def get_id(self, ref: TestRef, seed_ref: TestRef) -> ID:
        """(private API)"""
        pass
    # Misc
    # ImVec2      GetPosOnVoid(ImGuiViewport* viewport);                                  /* original C++ signature */
    def get_pos_on_void(self, viewport: Viewport) -> ImVec2:
        """(private API)

        Find a point that has no windows // FIXME: This needs error return and flag to enable/disable forcefully finding None.
        """
        pass
    # ImVec2      GetWindowTitlebarPoint(ImGuiTestRef window_ref);                        /* original C++ signature */
    def get_window_titlebar_point(self, window_ref: TestRef) -> ImVec2:
        """(private API)

        Return a clickable point on window title-bar (window tab for docked windows).
        """
        pass
    # ImVec2      GetMainMonitorWorkPos();                                                /* original C++ signature */
    def get_main_monitor_work_pos(self) -> ImVec2:
        """(private API)

        Work pos and size of main viewport when viewports are disabled, or work pos and size of monitor containing main viewport when viewports are enabled.
        """
        pass
    # ImVec2      GetMainMonitorWorkSize();    /* original C++ signature */
    def get_main_monitor_work_size(self) -> ImVec2:
        """(private API)"""
        pass
    # Screenshot/Video Captures
    # void        CaptureReset();                                                         /* original C++ signature */
    def capture_reset(self) -> None:
        """(private API)

        Reset state (use when doing multiple captures)
        """
        pass
    # void        CaptureSetExtension(const char* ext);                                   /* original C++ signature */
    def capture_set_extension(self, ext: str) -> None:
        """(private API)

        Set capture file format (otherwise for video this default to EngineIO->VideoCaptureExtension)
        """
        pass
    # bool        CaptureAddWindow(ImGuiTestRef ref);                                     /* original C++ signature */
    def capture_add_window(self, ref: TestRef) -> bool:
        """(private API)

        Add window to be captured (default to capture everything)
        """
        pass
    # void        CaptureScreenshotWindow(ImGuiTestRef ref, int capture_flags = 0);       /* original C++ signature */
    def capture_screenshot_window(self, ref: TestRef, capture_flags: int = 0) -> None:
        """(private API)

        Trigger a screen capture of a single window (== CaptureAddWindow() + CaptureScreenshot())
        """
        pass
    # bool        CaptureScreenshot(int capture_flags = 0);                               /* original C++ signature */
    def capture_screenshot(self, capture_flags: int = 0) -> bool:
        """(private API)

        Trigger a screen capture
        """
        pass
    # bool        CaptureBeginVideo();                                                    /* original C++ signature */
    def capture_begin_video(self) -> bool:
        """(private API)

        Start a video capture
        """
        pass
    # bool        CaptureEndVideo();    /* original C++ signature */
    def capture_end_video(self) -> bool:
        """(private API)"""
        pass
    # Mouse inputs
    # void        MouseMove(ImGuiTestRef ref, ImGuiTestOpFlags flags = ImGuiTestOpFlags_None);    /* original C++ signature */
    def mouse_move(self, ref: TestRef, flags: TestOpFlags = TestOpFlags_None) -> None:
        """(private API)"""
        pass
    # void        MouseMoveToPos(ImVec2 pos);    /* original C++ signature */
    def mouse_move_to_pos(self, pos: ImVec2) -> None:
        """(private API)"""
        pass
    # void        MouseTeleportToPos(ImVec2 pos);    /* original C++ signature */
    def mouse_teleport_to_pos(self, pos: ImVec2) -> None:
        """(private API)"""
        pass
    # void        MouseClick(ImGuiMouseButton button = 0);    /* original C++ signature */
    def mouse_click(self, button: MouseButton = 0) -> None:
        """(private API)"""
        pass
    # void        MouseClickMulti(ImGuiMouseButton button, int count);    /* original C++ signature */
    def mouse_click_multi(self, button: MouseButton, count: int) -> None:
        """(private API)"""
        pass
    # void        MouseDoubleClick(ImGuiMouseButton button = 0);    /* original C++ signature */
    def mouse_double_click(self, button: MouseButton = 0) -> None:
        """(private API)"""
        pass
    # void        MouseDown(ImGuiMouseButton button = 0);    /* original C++ signature */
    def mouse_down(self, button: MouseButton = 0) -> None:
        """(private API)"""
        pass
    # void        MouseUp(ImGuiMouseButton button = 0);    /* original C++ signature */
    def mouse_up(self, button: MouseButton = 0) -> None:
        """(private API)"""
        pass
    # void        MouseLiftDragThreshold(ImGuiMouseButton button = 0);    /* original C++ signature */
    def mouse_lift_drag_threshold(self, button: MouseButton = 0) -> None:
        """(private API)"""
        pass
    # void        MouseDragWithDelta(ImVec2 delta, ImGuiMouseButton button = 0);    /* original C++ signature */
    def mouse_drag_with_delta(self, delta: ImVec2, button: MouseButton = 0) -> None:
        """(private API)"""
        pass
    # void        MouseWheel(ImVec2 delta);    /* original C++ signature */
    def mouse_wheel(self, delta: ImVec2) -> None:
        """(private API)"""
        pass
    # void        MouseWheelX(float dx) { MouseWheel(ImVec2(dx, 0.0f)); }    /* original C++ signature */
    def mouse_wheel_x(self, dx: float) -> None:
        """(private API)"""
        pass
    # void        MouseWheelY(float dy) { MouseWheel(ImVec2(0.0f, dy)); }    /* original C++ signature */
    def mouse_wheel_y(self, dy: float) -> None:
        """(private API)"""
        pass
    # void        MouseMoveToVoid(ImGuiViewport* viewport = NULL);    /* original C++ signature */
    def mouse_move_to_void(self, viewport: Optional[Viewport] = None) -> None:
        """(private API)"""
        pass
    # void        MouseClickOnVoid(ImGuiMouseButton button = 0, ImGuiViewport* viewport = NULL);    /* original C++ signature */
    def mouse_click_on_void(
        self, button: MouseButton = 0, viewport: Optional[Viewport] = None
    ) -> None:
        """(private API)"""
        pass
    # ImGuiWindow*FindHoveredWindowAtPos(const ImVec2& pos);    /* original C++ signature */
    def find_hovered_window_at_pos(self, pos: ImVec2) -> Window:
        """(private API)"""
        pass
    # bool        FindExistingVoidPosOnViewport(ImGuiViewport* viewport, ImVec2* out);    /* original C++ signature */
    def find_existing_void_pos_on_viewport(
        self, viewport: Viewport, out: ImVec2
    ) -> bool:
        """(private API)"""
        pass
    # Mouse inputs: Viewports
    # - This is automatically called by SetRef() and any mouse action taking an item reference (e.g. ItemClick("button"), MouseClick("button"))
    # - But when using raw position directy e.g. MouseMoveToPos() / MouseTeleportToPos() without referring to the parent window before, this needs to be set.
    # void        MouseSetViewport(ImGuiWindow* window);    /* original C++ signature */
    def mouse_set_viewport(self, window: Window) -> None:
        """(private API)"""
        pass
    # void        MouseSetViewportID(ImGuiID viewport_id);    /* original C++ signature */
    def mouse_set_viewport_id(self, viewport_id: ID) -> None:
        """(private API)"""
        pass
    # Keyboard inputs
    # void        KeyDown(ImGuiKeyChord key_chord);    /* original C++ signature */
    def key_down(self, key_chord: KeyChord) -> None:
        """(private API)"""
        pass
    # void        KeyUp(ImGuiKeyChord key_chord);    /* original C++ signature */
    def key_up(self, key_chord: KeyChord) -> None:
        """(private API)"""
        pass
    # void        KeyPress(ImGuiKeyChord key_chord, int count = 1);    /* original C++ signature */
    def key_press(self, key_chord: KeyChord, count: int = 1) -> None:
        """(private API)"""
        pass
    # void        KeyHold(ImGuiKeyChord key_chord, float time);    /* original C++ signature */
    def key_hold(self, key_chord: KeyChord, time: float) -> None:
        """(private API)"""
        pass
    # void        KeyChars(const char* chars);                    /* original C++ signature */
    def key_chars(self, chars: str) -> None:
        """(private API)

        Input characters
        """
        pass
    # void        KeyCharsAppend(const char* chars);              /* original C++ signature */
    def key_chars_append(self, chars: str) -> None:
        """(private API)

        Input characters at end of field
        """
        pass
    # void        KeyCharsAppendEnter(const char* chars);         /* original C++ signature */
    def key_chars_append_enter(self, chars: str) -> None:
        """(private API)

        Input characters at end of field, press Enter
        """
        pass
    # void        KeyCharsReplace(const char* chars);             /* original C++ signature */
    def key_chars_replace(self, chars: str) -> None:
        """(private API)

        Delete existing field then input characters
        """
        pass
    # void        KeyCharsReplaceEnter(const char* chars);        /* original C++ signature */
    def key_chars_replace_enter(self, chars: str) -> None:
        """(private API)

        Delete existing field then input characters, press Enter
        """
        pass
    # Navigation inputs
    # FIXME: Need some redesign/refactoring:
    # - This was initially intended to: replace mouse action with keyboard/gamepad
    # - Abstract keyboard vs gamepad actions
    # However this is widely inconsistent and unfinished at this point.
    # void        SetInputMode(ImGuiInputSource input_mode);      /* original C++ signature */
    def set_input_mode(self, input_mode: InputSource) -> None:
        """(private API)

        Mouse or Keyboard or Gamepad. In Keyboard or Gamepad mode, actions such as ItemClick or ItemInput are using nav facilities instead of Mouse.
        """
        pass
    # void        NavMoveTo(ImGuiTestRef ref);    /* original C++ signature */
    def nav_move_to(self, ref: TestRef) -> None:
        """(private API)"""
        pass
    # void        NavActivate();                                  /* original C++ signature */
    def nav_activate(self) -> None:
        """(private API)

        Activate current selected item: activate button, tweak sliders/drags. Equivalent of pressing Space on keyboard, ImGuiKey_GamepadFaceUp on a gamepad.
        """
        pass
    # void        NavInput();                                     /* original C++ signature */
    def nav_input(self) -> None:
        """(private API)

        Input into select item: input sliders/drags. Equivalent of pressing Enter on keyboard, ImGuiKey_GamepadFaceDown on a gamepad.
        """
        pass
    # void        ScrollTo(ImGuiTestRef ref, ImGuiAxis axis, float scroll_v, ImGuiTestOpFlags flags = ImGuiTestOpFlags_None);    /* original C++ signature */
    def scroll_to(
        self,
        ref: TestRef,
        axis: Axis,
        scroll_v: float,
        flags: TestOpFlags = TestOpFlags_None,
    ) -> None:
        """Scrolling
        (private API)
        """
        pass
    # void        ScrollToX(ImGuiTestRef ref, float scroll_x) { ScrollTo(ref, ImGuiAxis_X, scroll_x); }    /* original C++ signature */
    def scroll_to_x(self, ref: TestRef, scroll_x: float) -> None:
        """(private API)"""
        pass
    # void        ScrollToY(ImGuiTestRef ref, float scroll_y) { ScrollTo(ref, ImGuiAxis_Y, scroll_y); }    /* original C++ signature */
    def scroll_to_y(self, ref: TestRef, scroll_y: float) -> None:
        """(private API)"""
        pass
    # void        ScrollToTop(ImGuiTestRef ref);    /* original C++ signature */
    def scroll_to_top(self, ref: TestRef) -> None:
        """(private API)"""
        pass
    # void        ScrollToBottom(ImGuiTestRef ref);    /* original C++ signature */
    def scroll_to_bottom(self, ref: TestRef) -> None:
        """(private API)"""
        pass
    # void        ScrollToItem(ImGuiTestRef ref, ImGuiAxis axis, ImGuiTestOpFlags flags = ImGuiTestOpFlags_None);    /* original C++ signature */
    def scroll_to_item(
        self, ref: TestRef, axis: Axis, flags: TestOpFlags = TestOpFlags_None
    ) -> None:
        """(private API)"""
        pass
    # void        ScrollToItemX(ImGuiTestRef ref);    /* original C++ signature */
    def scroll_to_item_x(self, ref: TestRef) -> None:
        """(private API)"""
        pass
    # void        ScrollToItemY(ImGuiTestRef ref);    /* original C++ signature */
    def scroll_to_item_y(self, ref: TestRef) -> None:
        """(private API)"""
        pass
    # void        ScrollToTabItem(ImGuiTabBar* tab_bar, ImGuiID tab_id);    /* original C++ signature */
    def scroll_to_tab_item(self, tab_bar: TabBar, tab_id: ID) -> None:
        """(private API)"""
        pass
    # bool        ScrollErrorCheck(ImGuiAxis axis, float expected, float actual, int* remaining_attempts);    /* original C++ signature */
    def scroll_error_check(
        self, axis: Axis, expected: float, actual: float, remaining_attempts: int
    ) -> Tuple[bool, int]:
        """(private API)"""
        pass
    # void        ScrollVerifyScrollMax(ImGuiTestRef ref);    /* original C++ signature */
    def scroll_verify_scroll_max(self, ref: TestRef) -> None:
        """(private API)"""
        pass
    # Low-level queries
    # Since 2022/06/25 to faciliate test code and reduce crashes: ItemInfo queries never return a None pointer, instead they return an empty instance (info->IsEmpty(), info->ID == 0).
    # ImGuiTestItemInfo*  ItemInfo(ImGuiTestRef ref, ImGuiTestOpFlags flags = ImGuiTestOpFlags_None);    /* original C++ signature */
    def item_info(
        self, ref: TestRef, flags: TestOpFlags = TestOpFlags_None
    ) -> TestItemInfo:
        """(private API)"""
        pass
    # ImGuiTestItemInfo*  ItemInfoOpenFullPath(ImGuiTestRef ref, ImGuiTestOpFlags flags = ImGuiTestOpFlags_None);    /* original C++ signature */
    def item_info_open_full_path(
        self, ref: TestRef, flags: TestOpFlags = TestOpFlags_None
    ) -> TestItemInfo:
        """(private API)"""
        pass
    # ImGuiID             ItemInfoHandleWildcardSearch(const char* wildcard_prefix_start, const char* wildcard_prefix_end, const char* wildcard_suffix_start);    /* original C++ signature */
    def item_info_handle_wildcard_search(
        self,
        wildcard_prefix_start: str,
        wildcard_prefix_end: str,
        wildcard_suffix_start: str,
    ) -> ID:
        """(private API)"""
        pass
    # ImGuiTestItemInfo*  ItemInfoNull();    /* original C++ signature */
    def item_info_null(self) -> TestItemInfo:
        """(private API)"""
        pass
    # void                GatherItems(ImGuiTestItemList* out_list, ImGuiTestRef parent, int depth = -1);    /* original C++ signature */
    def gather_items(
        self, out_list: TestItemList, parent: TestRef, depth: int = -1
    ) -> None:
        """(private API)"""
        pass
    # void        ItemAction(ImGuiTestAction action, ImGuiTestRef ref, ImGuiTestOpFlags flags = 0, void* action_arg = NULL);    /* original C++ signature */
    def item_action(
        self,
        action: TestAction,
        ref: TestRef,
        flags: TestOpFlags = 0,
        action_arg: Optional[Any] = None,
    ) -> None:
        """Item/Widgets manipulation
        (private API)
        """
        pass
    # void        ItemClick(ImGuiTestRef ref, ImGuiMouseButton button = 0, ImGuiTestOpFlags flags = 0) { ItemAction(ImGuiTestAction_Click, ref, flags, (void*)(size_t)button); }    /* original C++ signature */
    def item_click(
        self, ref: TestRef, button: MouseButton = 0, flags: TestOpFlags = 0
    ) -> None:
        """(private API)"""
        pass
    # void        ItemDoubleClick(ImGuiTestRef ref, ImGuiTestOpFlags flags = 0)           { ItemAction(ImGuiTestAction_DoubleClick, ref, flags); }    /* original C++ signature */
    def item_double_click(self, ref: TestRef, flags: TestOpFlags = 0) -> None:
        """(private API)"""
        pass
    # void        ItemCheck(ImGuiTestRef ref, ImGuiTestOpFlags flags = 0)                 { ItemAction(ImGuiTestAction_Check, ref, flags); }    /* original C++ signature */
    def item_check(self, ref: TestRef, flags: TestOpFlags = 0) -> None:
        """(private API)"""
        pass
    # void        ItemUncheck(ImGuiTestRef ref, ImGuiTestOpFlags flags = 0)               { ItemAction(ImGuiTestAction_Uncheck, ref, flags); }    /* original C++ signature */
    def item_uncheck(self, ref: TestRef, flags: TestOpFlags = 0) -> None:
        """(private API)"""
        pass
    # void        ItemOpen(ImGuiTestRef ref, ImGuiTestOpFlags flags = 0)                  { ItemAction(ImGuiTestAction_Open, ref, flags); }    /* original C++ signature */
    def item_open(self, ref: TestRef, flags: TestOpFlags = 0) -> None:
        """(private API)"""
        pass
    # void        ItemClose(ImGuiTestRef ref, ImGuiTestOpFlags flags = 0)                 { ItemAction(ImGuiTestAction_Close, ref, flags); }    /* original C++ signature */
    def item_close(self, ref: TestRef, flags: TestOpFlags = 0) -> None:
        """(private API)"""
        pass
    # void        ItemInput(ImGuiTestRef ref, ImGuiTestOpFlags flags = 0)                 { ItemAction(ImGuiTestAction_Input, ref, flags); }    /* original C++ signature */
    def item_input(self, ref: TestRef, flags: TestOpFlags = 0) -> None:
        """(private API)"""
        pass
    # void        ItemNavActivate(ImGuiTestRef ref, ImGuiTestOpFlags flags = 0)           { ItemAction(ImGuiTestAction_NavActivate, ref, flags); }    /* original C++ signature */
    def item_nav_activate(self, ref: TestRef, flags: TestOpFlags = 0) -> None:
        """(private API)"""
        pass
    # Item/Widgets: Batch actions over an entire scope
    # void        ItemActionAll(ImGuiTestAction action, ImGuiTestRef ref_parent, const ImGuiTestActionFilter* filter = NULL);    /* original C++ signature */
    def item_action_all(
        self,
        action: TestAction,
        ref_parent: TestRef,
        filter: Optional[TestActionFilter] = None,
    ) -> None:
        """(private API)"""
        pass
    # void        ItemOpenAll(ImGuiTestRef ref_parent, int depth = -1, int passes = -1);    /* original C++ signature */
    def item_open_all(
        self, ref_parent: TestRef, depth: int = -1, passes: int = -1
    ) -> None:
        """(private API)"""
        pass
    # void        ItemCloseAll(ImGuiTestRef ref_parent, int depth = -1, int passes = -1);    /* original C++ signature */
    def item_close_all(
        self, ref_parent: TestRef, depth: int = -1, passes: int = -1
    ) -> None:
        """(private API)"""
        pass
    # Item/Widgets: Helpers to easily set a value
    # void        ItemInputValue(ImGuiTestRef ref, int v);    /* original C++ signature */
    @overload
    def item_input_value(self, ref: TestRef, v: int) -> None:
        """(private API)"""
        pass
    # void        ItemInputValue(ImGuiTestRef ref, float f);    /* original C++ signature */
    @overload
    def item_input_value(self, ref: TestRef, f: float) -> None:
        """(private API)"""
        pass
    # void        ItemInputValue(ImGuiTestRef ref, const char* str);    /* original C++ signature */
    @overload
    def item_input_value(self, ref: TestRef, str: str) -> None:
        """(private API)"""
        pass
    # Item/Widgets: Drag and Mouse operations
    # void        ItemHold(ImGuiTestRef ref, float time);    /* original C++ signature */
    def item_hold(self, ref: TestRef, time: float) -> None:
        """(private API)"""
        pass
    # void        ItemHoldForFrames(ImGuiTestRef ref, int frames);    /* original C++ signature */
    def item_hold_for_frames(self, ref: TestRef, frames: int) -> None:
        """(private API)"""
        pass
    # void        ItemDragOverAndHold(ImGuiTestRef ref_src, ImGuiTestRef ref_dst);    /* original C++ signature */
    def item_drag_over_and_hold(self, ref_src: TestRef, ref_dst: TestRef) -> None:
        """(private API)"""
        pass
    # void        ItemDragAndDrop(ImGuiTestRef ref_src, ImGuiTestRef ref_dst, ImGuiMouseButton button = 0);    /* original C++ signature */
    def item_drag_and_drop(
        self, ref_src: TestRef, ref_dst: TestRef, button: MouseButton = 0
    ) -> None:
        """(private API)"""
        pass
    # void        ItemDragWithDelta(ImGuiTestRef ref_src, ImVec2 pos_delta);    /* original C++ signature */
    def item_drag_with_delta(self, ref_src: TestRef, pos_delta: ImVec2) -> None:
        """(private API)"""
        pass
    # Helpers for Item/Widget state query
    # bool        ItemExists(ImGuiTestRef ref);    /* original C++ signature */
    def item_exists(self, ref: TestRef) -> bool:
        """(private API)"""
        pass
    # bool        ItemIsChecked(ImGuiTestRef ref);    /* original C++ signature */
    def item_is_checked(self, ref: TestRef) -> bool:
        """(private API)"""
        pass
    # bool        ItemIsOpened(ImGuiTestRef ref);    /* original C++ signature */
    def item_is_opened(self, ref: TestRef) -> bool:
        """(private API)"""
        pass
    # void        ItemVerifyCheckedIfAlive(ImGuiTestRef ref, bool checked);    /* original C++ signature */
    def item_verify_checked_if_alive(self, ref: TestRef, checked: bool) -> None:
        """(private API)"""
        pass
    # Helpers for Tab Bars widgets
    # void        TabClose(ImGuiTestRef ref);    /* original C++ signature */
    def tab_close(self, ref: TestRef) -> None:
        """(private API)"""
        pass
    # Helpers for Menus widgets
    # void        MenuAction(ImGuiTestAction action, ImGuiTestRef ref);    /* original C++ signature */
    def menu_action(self, action: TestAction, ref: TestRef) -> None:
        """(private API)"""
        pass
    # void        MenuActionAll(ImGuiTestAction action, ImGuiTestRef ref_parent);    /* original C++ signature */
    def menu_action_all(self, action: TestAction, ref_parent: TestRef) -> None:
        """(private API)"""
        pass
    # void        MenuClick(ImGuiTestRef ref)                 { MenuAction(ImGuiTestAction_Click, ref); }    /* original C++ signature */
    def menu_click(self, ref: TestRef) -> None:
        """(private API)"""
        pass
    # void        MenuCheck(ImGuiTestRef ref)                 { MenuAction(ImGuiTestAction_Check, ref); }    /* original C++ signature */
    def menu_check(self, ref: TestRef) -> None:
        """(private API)"""
        pass
    # void        MenuUncheck(ImGuiTestRef ref)               { MenuAction(ImGuiTestAction_Uncheck, ref); }    /* original C++ signature */
    def menu_uncheck(self, ref: TestRef) -> None:
        """(private API)"""
        pass
    # void        MenuCheckAll(ImGuiTestRef ref_parent)       { MenuActionAll(ImGuiTestAction_Check, ref_parent); }    /* original C++ signature */
    def menu_check_all(self, ref_parent: TestRef) -> None:
        """(private API)"""
        pass
    # void        MenuUncheckAll(ImGuiTestRef ref_parent)     { MenuActionAll(ImGuiTestAction_Uncheck, ref_parent); }    /* original C++ signature */
    def menu_uncheck_all(self, ref_parent: TestRef) -> None:
        """(private API)"""
        pass
    # Helpers for Combo Boxes
    # void        ComboClick(ImGuiTestRef ref);    /* original C++ signature */
    def combo_click(self, ref: TestRef) -> None:
        """(private API)"""
        pass
    # void        ComboClickAll(ImGuiTestRef ref);    /* original C++ signature */
    def combo_click_all(self, ref: TestRef) -> None:
        """(private API)"""
        pass
    # Helpers for Tables
    # void                        TableOpenContextMenu(ImGuiTestRef ref, int column_n = -1);    /* original C++ signature */
    def table_open_context_menu(self, ref: TestRef, column_n: int = -1) -> None:
        """(private API)"""
        pass
    # ImGuiSortDirection          TableClickHeader(ImGuiTestRef ref, const char* label, ImGuiKeyChord key_mods = 0);    /* original C++ signature */
    def table_click_header(
        self, ref: TestRef, label: str, key_mods: KeyChord = 0
    ) -> SortDirection:
        """(private API)"""
        pass
    # void                        TableSetColumnEnabled(ImGuiTestRef ref, const char* label, bool enabled);    /* original C++ signature */
    def table_set_column_enabled(self, ref: TestRef, label: str, enabled: bool) -> None:
        """(private API)"""
        pass
    # void                        TableResizeColumn(ImGuiTestRef ref, int column_n, float width);    /* original C++ signature */
    def table_resize_column(self, ref: TestRef, column_n: int, width: float) -> None:
        """(private API)"""
        pass
    # const ImGuiTableSortSpecs*  TableGetSortSpecs(ImGuiTestRef ref);    /* original C++ signature */
    def table_get_sort_specs(self, ref: TestRef) -> TableSortSpecs:
        """(private API)"""
        pass
    # Viewports
    # IMPORTANT: Those function may alter Platform state (unless using the "Mock Viewport" backend). Use carefully.
    # Those are mostly useful to simulate OS actions and testing of viewport-specific features, may not be useful to most users.

    # Docking
    #                                                  #ifdef IMGUI_HAS_DOCK
    #
    # void        DockClear(const char* window_name, ...);    /* original C++ signature */
    def dock_clear(self, window_name: str) -> None:
        """(private API)"""
        pass
    # void        DockInto(ImGuiTestRef src_id, ImGuiTestRef dst_id, ImGuiDir split_dir = ImGuiDir_None, bool is_outer_docking = false, ImGuiTestOpFlags flags = 0);    /* original C++ signature */
    def dock_into(
        self,
        src_id: TestRef,
        dst_id: TestRef,
        split_dir: Dir = Dir_None,
        is_outer_docking: bool = False,
        flags: TestOpFlags = 0,
    ) -> None:
        """(private API)"""
        pass
    # void        UndockNode(ImGuiID dock_id);    /* original C++ signature */
    def undock_node(self, dock_id: ID) -> None:
        """(private API)"""
        pass
    # void        UndockWindow(const char* window_name);    /* original C++ signature */
    def undock_window(self, window_name: str) -> None:
        """(private API)"""
        pass
    # bool        WindowIsUndockedOrStandalone(ImGuiWindow* window);    /* original C++ signature */
    def window_is_undocked_or_standalone(self, window: Window) -> bool:
        """(private API)"""
        pass
    # bool        DockIdIsUndockedOrStandalone(ImGuiID dock_id);    /* original C++ signature */
    def dock_id_is_undocked_or_standalone(self, dock_id: ID) -> bool:
        """(private API)"""
        pass
    # void        DockNodeHideTabBar(ImGuiDockNode* node, bool hidden);    /* original C++ signature */
    def dock_node_hide_tab_bar(self, node: DockNode, hidden: bool) -> None:
        """(private API)"""
        pass
    #                                                  #endif
    #

    # Performances
    # void        PerfCalcRef();    /* original C++ signature */
    def perf_calc_ref(self) -> None:
        """(private API)"""
        pass
    # void        PerfCapture(const char* category = NULL, const char* test_name = NULL, const char* csv_file = NULL);    /* original C++ signature */
    def perf_capture(
        self,
        category: Optional[str] = None,
        test_name: Optional[str] = None,
        csv_file: Optional[str] = None,
    ) -> None:
        """(private API)"""
        pass
    # Obsolete functions

    # [Internal]
    # FIXME: Aim to remove this system...
    # void        ForeignWindowsUnhideAll();    /* original C++ signature */
    def foreign_windows_unhide_all(self) -> None:
        """(private API)"""
        pass
    # ImGuiTestContext(ImGuiTestGenericVars GenericVars = ImGuiTestGenericVars(), ImGuiTestOpFlags OpFlags = ImGuiTestOpFlags_None, int PerfStressAmount = 0, int FrameCount = 0, int FirstTestFrameCount = 0, bool FirstGuiFrame = false, bool HasDock = false, ImGuiTestRunFlags RunFlags = ImGuiTestRunFlags_None, ImGuiTestActiveFunc ActiveFunc = ImGuiTestActiveFunc_None, double RunningTime = 0.0, int ActionDepth = 0, int CaptureCounter = 0, int ErrorCounter = 0, bool Abort = false, double PerfRefDt = -1.0, int PerfIterations = 400, ImGuiID RefID = 0, ImGuiID RefWindowID = 0, ImGuiInputSource InputMode = ImGuiInputSource_Mouse, ImGuiTestItemInfo DummyItemInfoNull = ImGuiTestItemInfo(), bool CachedLinesPrintedToTTY = false);    /* original C++ signature */
    def __init__(
        self,
        generic_vars: TestGenericVars = TestGenericVars(),
        op_flags: TestOpFlags = TestOpFlags_None,
        perf_stress_amount: int = 0,
        frame_count: int = 0,
        first_test_frame_count: int = 0,
        first_gui_frame: bool = False,
        has_dock: bool = False,
        run_flags: TestRunFlags = TestRunFlags_None,
        active_func: TestActiveFunc = TestActiveFunc_None,
        running_time: float = 0.0,
        action_depth: int = 0,
        capture_counter: int = 0,
        error_counter: int = 0,
        abort: bool = False,
        perf_ref_dt: float = -1.0,
        perf_iterations: int = 400,
        ref_id: ID = 0,
        ref_window_id: ID = 0,
        input_mode: InputSource = InputSource_Mouse,
        dummy_item_info_null: TestItemInfo = TestItemInfo(),
        cached_lines_printed_to_tty: bool = False,
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# -------------------------------------------------------------------------
# [SECTION] Debugging macros (IM_SUSPEND_TESTFUNC)
# -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# [SECTION] Testing/Checking macros: IM_CHECK(), IM_ERRORF() etc.
# -------------------------------------------------------------------------

# We embed every macro in a do {} while(0) statement as a trick to allow using them as regular single statement, e.g. if (XXX) IM_CHECK(A); else IM_CHECK(B)
# We leave the IM_DEBUG_BREAK() outside of the check function to step out faster when using a debugger. It also has the benefit of being lighter than an IM_ASSERT().

# Scalar compares

# Scalar compares, without return on failure

# String compares

# Floating point compares

# -------------------------------------------------------------------------
####################    </generated_from:imgui_te_context.h>    ####################


####################    <generated_from:imgui_te_internal.h>    ####################
# dear imgui test engine
# (internal api)

# -------------------------------------------------------------------------
# FORWARD DECLARATIONS
# -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# DATA STRUCTURES
# -------------------------------------------------------------------------

class TestInfoTask:
    """Query item position/window/state given ID."""

    # Input
    # ImGuiID                 ID = 0;    /* original C++ signature */
    id_: ID = 0
    # int                     FrameCount = -1;    /* original C++ signature */
    frame_count: int = -1  # Timestamp of request

    # ImGuiTestItemInfo       Result;    /* original C++ signature */
    # Output
    result: TestItemInfo
    # ImGuiTestInfoTask(ImGuiID ID = 0, int FrameCount = -1, ImGuiTestItemInfo Result = ImGuiTestItemInfo());    /* original C++ signature */
    def __init__(
        self, id_: ID = 0, frame_count: int = -1, result: TestItemInfo = TestItemInfo()
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

class TestGatherTask:
    """Gather item list in given parent ID."""

    # Input
    # ImGuiID                 InParentID = 0;    /* original C++ signature */
    in_parent_id: ID = 0
    # int                     InMaxDepth = 0;    /* original C++ signature */
    in_max_depth: int = 0
    # short                   InLayerMask = 0;    /* original C++ signature */
    in_layer_mask: int = 0

    # Output/Temp
    # ImGuiTestItemList*      OutList = NULL;    /* original C++ signature */
    out_list: TestItemList = None
    # ImGuiTestItemInfo*      LastItemInfo = NULL;    /* original C++ signature */
    last_item_info: TestItemInfo = None

    # void Clear() { memset(this, 0, sizeof(*this)); }    /* original C++ signature */
    def clear(self) -> None:
        """(private API)"""
        pass
    # ImGuiTestGatherTask(ImGuiID InParentID = 0, int InMaxDepth = 0, short InLayerMask = 0);    /* original C++ signature */
    def __init__(
        self, in_parent_id: ID = 0, in_max_depth: int = 0, in_layer_mask: int = 0
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

class TestFindByLabelTask:
    """Find item ID given a label and a parent id
    Usually used by queries with wildcards such as ItemInfo("hello/**/foo/bar")
    """

    # Input
    # ImGuiID                 InPrefixId = 0;    /* original C++ signature */
    in_prefix_id: ID = 0  # A known base ID which appears BEFORE the wildcard ID (for "hello/**/foo/bar" it would be hash of "hello")
    # int                     InSuffixDepth = 0;    /* original C++ signature */
    in_suffix_depth: int = 0  # Number of labels in a path, after unknown base ID (for "hello/**/foo/bar" it would be 2)
    # const char*             InSuffix = NULL;    /* original C++ signature */
    in_suffix: str = None  # A label string which appears on ID stack after unknown base ID (for "hello/**/foo/bar" it would be "foo/bar")
    # const char*             InSuffixLastItem = NULL;    /* original C++ signature */
    in_suffix_last_item: str = (
        None  # A last label string (for "hello/**/foo/bar" it would be "bar")
    )
    # ImGuiID                 InSuffixLastItemHash = 0;    /* original C++ signature */
    in_suffix_last_item_hash: ID = 0
    # ImGuiItemStatusFlags    InFilterItemStatusFlags = 0;    /* original C++ signature */
    in_filter_item_status_flags: ItemStatusFlags = (
        0  # Flags required for item to be returned
    )

    # Output
    # ImGuiID                 OutItemId = 0;    /* original C++ signature */
    out_item_id: ID = 0  # Result item ID
    # ImGuiTestFindByLabelTask(ImGuiID InPrefixId = 0, int InSuffixDepth = 0, ImGuiID InSuffixLastItemHash = 0, ImGuiItemStatusFlags InFilterItemStatusFlags = 0, ImGuiID OutItemId = 0);    /* original C++ signature */
    def __init__(
        self,
        in_prefix_id: ID = 0,
        in_suffix_depth: int = 0,
        in_suffix_last_item_hash: ID = 0,
        in_filter_item_status_flags: ItemStatusFlags = 0,
        out_item_id: ID = 0,
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

class TestInputType(enum.Enum):
    # ImGuiTestInputType_None,    /* original C++ signature */
    none = enum.auto()  # (= 0)
    # ImGuiTestInputType_Key,    /* original C++ signature */
    key = enum.auto()  # (= 1)
    # ImGuiTestInputType_Char,    /* original C++ signature */
    char = enum.auto()  # (= 2)
    # ImGuiTestInputType_ViewportFocus,    /* original C++ signature */
    viewport_focus = enum.auto()  # (= 3)
    # ImGuiTestInputType_ViewportClose    /* original C++ signature */
    # }
    viewport_close = enum.auto()  # (= 4)

class TestInput:
    """FIXME: May want to strip further now that core imgui is using its own input queue"""

    # ImGuiTestInputType      Type = ImGuiTestInputType_None;    /* original C++ signature */
    type: TestInputType = TestInputType_None
    # ImGuiKeyChord           KeyChord = ImGuiKey_None;    /* original C++ signature */
    key_chord: KeyChord = Key_None
    # ImWchar                 Char = 0;    /* original C++ signature */
    char: ImWchar = 0
    # bool                    Down = false;    /* original C++ signature */
    down: bool = False
    # ImGuiID                 ViewportId = 0;    /* original C++ signature */
    viewport_id: ID = 0

    # static ImGuiTestInput   ForKeyChord(ImGuiKeyChord key_chord, bool down)    /* original C++ signature */
    #     {
    #         ImGuiTestInput inp;
    #         inp.Type = ImGuiTestInputType_Key;
    #         inp.KeyChord = key_chord;
    #         inp.Down = down;
    #         return inp;
    #     }
    @staticmethod
    def for_key_chord(key_chord: KeyChord, down: bool) -> TestInput:
        """(private API)"""
        pass
    # static ImGuiTestInput   ForChar(ImWchar v)    /* original C++ signature */
    #     {
    #         ImGuiTestInput inp;
    #         inp.Type = ImGuiTestInputType_Char;
    #         inp.Char = v;
    #         return inp;
    #     }
    @staticmethod
    def for_char(v: ImWchar) -> TestInput:
        """(private API)"""
        pass
    # static ImGuiTestInput   ForViewportFocus(ImGuiID viewport_id)    /* original C++ signature */
    #     {
    #         ImGuiTestInput inp;
    #         inp.Type = ImGuiTestInputType_ViewportFocus;
    #         inp.ViewportId = viewport_id;
    #         return inp;
    #     }
    @staticmethod
    def for_viewport_focus(viewport_id: ID) -> TestInput:
        """(private API)"""
        pass
    # static ImGuiTestInput   ForViewportClose(ImGuiID viewport_id)    /* original C++ signature */
    #     {
    #         ImGuiTestInput inp;
    #         inp.Type = ImGuiTestInputType_ViewportClose;
    #         inp.ViewportId = viewport_id;
    #         return inp;
    #     }
    @staticmethod
    def for_viewport_close(viewport_id: ID) -> TestInput:
        """(private API)"""
        pass
    # ImGuiTestInput(ImGuiTestInputType Type = ImGuiTestInputType_None, ImGuiKeyChord KeyChord = ImGuiKey_None, ImWchar Char = 0, bool Down = false, ImGuiID ViewportId = 0);    /* original C++ signature */
    def __init__(
        self,
        type: TestInputType = TestInputType_None,
        key_chord: KeyChord = Key_None,
        char: ImWchar = 0,
        down: bool = False,
        viewport_id: ID = 0,
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

class TestInputs:
    # ImVec2                      MousePosValue;    /* original C++ signature */
    mouse_pos_value: ImVec2  # Own non-rounded copy of MousePos in order facilitate simulating mouse movement very slow speed and high-framerate
    # ImVec2                      MouseWheel;    /* original C++ signature */
    mouse_wheel: ImVec2
    # ImGuiID                     MouseHoveredViewport = 0;    /* original C++ signature */
    mouse_hovered_viewport: ID = 0
    # int                         MouseButtonsValue = 0x00;    /* original C++ signature */
    mouse_buttons_value: int = 0x00  # FIXME-TESTS: Use simulated_io.MouseDown[] ?
    # bool                        HostEscDown = false;    /* original C++ signature */
    host_esc_down: bool = False
    # float                       HostEscDownDuration = -1.0f;    /* original C++ signature */
    host_esc_down_duration: float = (
        -1.0
    )  # Maintain our own DownDuration for host/backend ESC key so we can abort.
    # ImGuiTestInputs(ImVec2 MousePosValue = ImVec2(), ImVec2 MouseWheel = ImVec2(), ImGuiID MouseHoveredViewport = 0, int MouseButtonsValue = 0x00, bool HostEscDown = false, float HostEscDownDuration = -1.0f);    /* original C++ signature */
    def __init__(
        self,
        mouse_pos_value: ImVec2 = ImVec2(),
        mouse_wheel: ImVec2 = ImVec2(),
        mouse_hovered_viewport: ID = 0,
        mouse_buttons_value: int = 0x00,
        host_esc_down: bool = False,
        host_esc_down_duration: float = -1.0,
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

class TestEngine:
    """[Internal] Test Engine Context"""

    # ImGuiTestEngineIO           IO;    /* original C++ signature */
    io: TestEngineIO
    # ImGuiContext*               UiContextTarget = NULL;    /* original C++ signature */
    ui_context_target: Context = None  # imgui context for testing
    # ImGuiContext*               UiContextActive = NULL;    /* original C++ signature */
    ui_context_active: Context = (
        None  # imgui context for testing == UiContextTarget or None
    )

    # bool                        Started = false;    /* original C++ signature */
    started: bool = False
    # ImU64                       BatchStartTime = 0;    /* original C++ signature */
    batch_start_time: ImU64 = 0
    # ImU64                       BatchEndTime = 0;    /* original C++ signature */
    batch_end_time: ImU64 = 0
    # int                         FrameCount = 0;    /* original C++ signature */
    frame_count: int = 0
    # float                       OverrideDeltaTime = -1.0f;    /* original C++ signature */
    override_delta_time: float = (
        -1.0
    )  # Inject custom delta time into imgui context to simulate clock passing faster than wall clock time.
    # ImGuiTestContext*           TestContext = NULL;    /* original C++ signature */
    test_context: TestContext = None
    # ImGuiTestGatherTask         GatherTask;    /* original C++ signature */
    gather_task: TestGatherTask
    # ImGuiTestFindByLabelTask    FindByLabelTask;    /* original C++ signature */
    find_by_label_task: TestFindByLabelTask
    # void*                       UserDataBuffer = NULL;    /* original C++ signature */
    user_data_buffer: Any = None
    # size_t                      UserDataBufferSize = 0;    /* original C++ signature */
    user_data_buffer_size: int = 0

    # ImGuiTestInputs             Inputs;    /* original C++ signature */
    # Inputs
    inputs: TestInputs

    # UI support
    # bool                        Abort = false;    /* original C++ signature */
    abort: bool = False
    # ImGuiTest*                  UiSelectAndScrollToTest = NULL;    /* original C++ signature */
    ui_select_and_scroll_to_test: Test = None
    # ImGuiTest*                  UiSelectedTest = NULL;    /* original C++ signature */
    ui_selected_test: Test = None
    # bool                        UiMetricsOpen = false;    /* original C++ signature */
    ui_metrics_open: bool = False
    # bool                        UiDebugLogOpen = false;    /* original C++ signature */
    ui_debug_log_open: bool = False
    # bool                        UiCaptureToolOpen = false;    /* original C++ signature */
    ui_capture_tool_open: bool = False
    # bool                        UiStackToolOpen = false;    /* original C++ signature */
    ui_stack_tool_open: bool = False
    # bool                        UiPerfToolOpen = false;    /* original C++ signature */
    ui_perf_tool_open: bool = False
    # float                       UiLogHeight = 150.0f;    /* original C++ signature */
    ui_log_height: float = 150.0

    # Performance Monitor
    # double                      PerfRefDeltaTime;    /* original C++ signature */
    perf_ref_delta_time: float

    # Screen/Video Capturing

    # Tools
    # bool                        PostSwapCalled = false;    /* original C++ signature */
    post_swap_called: bool = False
    # bool                        ToolDebugRebootUiContext = false;    /* original C++ signature */
    tool_debug_reboot_ui_context: bool = (
        False  # Completely shutdown and recreate the dear imgui context in place
    )
    # bool                        ToolSlowDown = false;    /* original C++ signature */
    tool_slow_down: bool = False
    # int                         ToolSlowDownMs = 100;    /* original C++ signature */
    tool_slow_down_ms: int = 100
    # ImGuiTestRunSpeed           BackupConfigRunSpeed = ImGuiTestRunSpeed_Fast;    /* original C++ signature */
    backup_config_run_speed: TestRunSpeed = TestRunSpeed_Fast
    # bool                        BackupConfigNoThrottle = false;    /* original C++ signature */
    backup_config_no_throttle: bool = False

    # ImGuiTestEngine();    /* original C++ signature */
    def __init__(self) -> None:
        """Functions"""
        pass

# -------------------------------------------------------------------------
# INTERNAL FUNCTIONS
# -------------------------------------------------------------------------

# ImGuiTestItemInfo*  ImGuiTestEngine_FindItemInfo(ImGuiTestEngine* engine, ImGuiID id, const char* debug_id);    /* original C++ signature */
def find_item_info(engine: TestEngine, id_: ID, debug_id: str) -> TestItemInfo:
    """(private API)"""
    pass

# void                ImGuiTestEngine_Yield(ImGuiTestEngine* engine);    /* original C++ signature */
def yield_(engine: TestEngine) -> None:
    """(private API)"""
    pass

# void                ImGuiTestEngine_SetDeltaTime(ImGuiTestEngine* engine, float delta_time);    /* original C++ signature */
def set_delta_time(engine: TestEngine, delta_time: float) -> None:
    """(private API)"""
    pass

# int                 ImGuiTestEngine_GetFrameCount(ImGuiTestEngine* engine);    /* original C++ signature */
def get_frame_count(engine: TestEngine) -> int:
    """(private API)"""
    pass

# bool                ImGuiTestEngine_PassFilter(ImGuiTest* test, const char* filter);    /* original C++ signature */
def pass_filter(test: Test, filter: str) -> bool:
    """(private API)"""
    pass

# void                ImGuiTestEngine_RebootUiContext(ImGuiTestEngine* engine);    /* original C++ signature */
def reboot_ui_context(engine: TestEngine) -> None:
    """(private API)"""
    pass

# Screen/Video Capturing

# Helper functions
# const char*         ImGuiTestEngine_GetRunSpeedName(ImGuiTestRunSpeed v);    /* original C++ signature */
def get_run_speed_name(v: TestRunSpeed) -> str:
    """(private API)"""
    pass

# const char*         ImGuiTestEngine_GetVerboseLevelName(ImGuiTestVerboseLevel v);    /* original C++ signature */
def get_verbose_level_name(v: TestVerboseLevel) -> str:
    """(private API)"""
    pass

# -------------------------------------------------------------------------
####################    </generated_from:imgui_te_internal.h>    ####################


####################    <generated_from:imgui_te_ui.h>    ####################
# dear imgui test engine
# (ui)
# If you run tests in an interactive or visible application, you may want to call ImGuiTestEngine_ShowTestEngineWindows()

# Provide access to:
# - "Dear ImGui Test Engine" main interface
# - "Dear ImGui Capture Tool"
# - "Dear ImGui Perf Tool"
# - other core debug functions: Metrics, Debug Log

# IMGUI_API void    ImGuiTestEngine_ShowTestEngineWindows(ImGuiTestEngine* engine, bool* p_open);    /* original C++ signature */
def show_test_engine_windows(engine: TestEngine, p_open: bool) -> bool:
    """Functions"""
    pass
####################    </generated_from:imgui_te_ui.h>    ####################

# </litgen_stub>

# fmt: on
